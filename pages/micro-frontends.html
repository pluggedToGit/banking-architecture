<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micro Frontend Architecture - Banking Platform</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <h2><a href="../index.html">Banking Architecture</a></h2>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="../index.html" class="nav-link">Overview</a>
                </li>
                <li class="nav-item">
                    <a href="micro-frontends.html" class="nav-link active">Micro Frontends</a>
                </li>
                <li class="nav-item">
                    <a href="aws-architecture.html" class="nav-link">AWS Infrastructure</a>
                </li>
                <li class="nav-item">
                    <a href="performance.html" class="nav-link">Performance</a>
                </li>
                <li class="nav-item">
                    <a href="resilience.html" class="nav-link">Resilience</a>
                </li>
                <li class="nav-item">
                    <a href="ai-integration.html" class="nav-link">AI Integration</a>
                </li>
            </ul>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <main class="page-content">
        <div class="container">
            <div class="page-header">
                <h1>Dynamic Micro Frontend Architecture</h1>
                <p>Scalable, runtime-configurable micro frontend system for banking applications</p>
            </div>

            <div class="content-grid">
                <aside class="sidebar">
                    <nav class="page-nav">
                        <h3>Contents</h3>
                        <ul>
                            <li><a href="#overview">Architecture Overview</a></li>
                            <li><a href="#dynamic-discovery">Dynamic MFE Discovery</a></li>
                            <li><a href="#shell-architecture">Shell App Architecture</a></li>
                            <li><a href="#runtime-config">Runtime Configuration</a></li>
                            <li><a href="#module-federation">Module Federation</a></li>
                            <li><a href="#cors-security">CORS & Security</a></li>
                            <li><a href="#deployment-strategy">Deployment Strategy</a></li>
                            <li><a href="#versioning">Version Management</a></li>
                            <li><a href="#performance">Performance Optimization</a></li>
                        </ul>
                    </nav>
                </aside>

                <article class="main-content">
                    <section id="overview" class="content-section">
                        <h2>Micro Frontend Architecture Overview</h2>
                        <p>Our banking platform uses a dynamic micro frontend architecture that eliminates the need to constantly rebuild the shell application when new MFEs are added or updated.</p>

                        <div class="architecture-benefits">
                            <h3>Key Benefits</h3>
                            <div class="benefits-grid">
                                <div class="benefit-card">
                                    <h4>üöÄ Independent Deployments</h4>
                                    <p>Each MFE can be deployed independently without affecting the shell or other MFEs</p>
                                </div>
                                <div class="benefit-card">
                                    <h4>üîÑ Runtime Discovery</h4>
                                    <p>Shell app discovers new MFEs at runtime through dynamic configuration</p>
                                </div>
                                <div class="benefit-card">
                                    <h4>üì¶ Technology Agnostic</h4>
                                    <p>Different teams can use React, Vue, Angular, or vanilla JS for their MFEs</p>
                                </div>
                                <div class="benefit-card">
                                    <h4>üõ°Ô∏è Fault Isolation</h4>
                                    <p>If one MFE fails, others continue to function normally</p>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="dynamic-discovery" class="content-section">
                        <h2>üîç Dynamic MFE Discovery System</h2>
                        
                        <div class="discovery-strategy">
                            <h3>Discovery Mechanisms</h3>
                            <p>The shell app uses multiple strategies to discover and load MFEs dynamically without requiring code changes or redeployment.</p>
                            
                            <div class="discovery-methods">
                                <div class="discovery-method">
                                    <h4>üìã 1. Configuration-Based Discovery</h4>
                                    <div class="method-details">
                                        <p>MFE configurations are stored in DynamoDB and fetched at runtime, allowing instant updates without shell redeployment.</p>
                                        
                                        <div class="config-example">
                                            <h5>MFE Registry Configuration</h5>
                                            <pre><code class="language-json">{
  "mfe_registry": {
    "account-dashboard": {
      "id": "account-dashboard",
      "name": "Account Dashboard",
      "version": "2.1.3",
      "status": "active",
      "entry_point": "https://cdn.bank.com/mfes/account-dashboard/2.1.3/bundle.js",
      "css": "https://cdn.bank.com/mfes/account-dashboard/2.1.3/styles.css",
      "routes": ["/accounts", "/dashboard"],
      "permissions": ["accounts.read", "accounts.write"],
      "team": "accounts-team",
      "deployment_regions": ["us-east-1", "eu-west-1"],
      "feature_flags": {
        "dark_mode": true,
        "advanced_charts": false,
        "real_time_updates": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "banking_theme": "^2.0.1"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Customer account overview and management",
        "icon": "fas fa-chart-line",
        "priority": 1,
        "category": "core"
      }
    },
    "payment-transfer": {
      "id": "payment-transfer",
      "name": "Payment & Transfer",
      "version": "1.8.2",
      "status": "active",
      "entry_point": "https://cdn.bank.com/mfes/payment-transfer/1.8.2/bundle.js",
      "css": "https://cdn.bank.com/mfes/payment-transfer/1.8.2/styles.css",
      "routes": ["/payments", "/transfers"],
      "permissions": ["payments.create", "transfers.create"],
      "team": "payments-team",
      "deployment_regions": ["us-east-1", "eu-west-1"],
      "feature_flags": {
        "international_transfers": true,
        "crypto_support": false,
        "instant_payments": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "payment_validation": "^3.2.1"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Payment processing and money transfers",
        "icon": "fas fa-credit-card",
        "priority": 2,
        "category": "core"
      }
    },
    "investment-portfolio": {
      "id": "investment-portfolio",
      "name": "Investment Portfolio",
      "version": "1.2.0-beta",
      "status": "beta",
      "entry_point": "https://cdn.bank.com/mfes/investment-portfolio/1.2.0-beta/bundle.js",
      "css": "https://cdn.bank.com/mfes/investment-portfolio/1.2.0-beta/styles.css",
      "routes": ["/investments", "/portfolio"],
      "permissions": ["investments.read", "portfolio.manage"],
      "team": "wealth-management-team",
      "deployment_regions": ["us-east-1"],
      "rollout_percentage": 10,
      "target_user_segments": ["premium", "wealth_management"],
      "feature_flags": {
        "options_trading": false,
        "crypto_investments": false,
        "ai_recommendations": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "market_data": "^2.1.0"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Investment portfolio management and tracking",
        "icon": "fas fa-chart-pie",
        "priority": 3,
        "category": "premium"
      }
    }
  },
  "global_config": {
    "theme": "corporate-2024",
    "api_base_url": "https://api.bank.com/v2",
    "feature_toggles": {
      "maintenance_mode": false,
      "new_user_onboarding": true,
      "beta_features_enabled": true
    },
    "performance_budgets": {
      "max_bundle_size": "250kb",
      "max_load_time": "2000ms"
    }
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="discovery-method">
                                    <h4>üîÑ 2. Runtime Registration API</h4>
                                    <div class="method-details">
                                        <p>New MFEs can register themselves with the shell app through a registration API, enabling immediate availability.</p>
                                        
                                        <div class="api-example">
                                            <h5>MFE Registration Endpoint</h5>
                                            <pre><code class="language-typescript">// MFE Registration API
interface MFERegistration {
  id: string;
  name: string;
  version: string;
  entryPoint: string;
  routes: string[];
  permissions: string[];
  healthCheck?: string;
  metadata?: MFEMetadata;
}

class MFERegistryService {
  private registryEndpoint = 'https://api.bank.com/mfe-registry';
  
  async registerMFE(registration: MFERegistration): Promise<void> {
    const response = await fetch(`${this.registryEndpoint}/register`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify({
        ...registration,
        timestamp: new Date().toISOString(),
        deploymentId: process.env.DEPLOYMENT_ID,
        region: process.env.AWS_REGION
      })
    });
    
    if (!response.ok) {
      throw new Error(`Failed to register MFE: ${response.statusText}`);
    }
    
    // Notify all shell instances of the new MFE
    await this.notifyShellInstances(registration);
  }
  
  async updateMFE(id: string, updates: Partial<MFERegistration>): Promise<void> {
    await fetch(`${this.registryEndpoint}/mfes/${id}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify(updates)
    });
  }
  
  async deregisterMFE(id: string): Promise<void> {
    await fetch(`${this.registryEndpoint}/mfes/${id}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${this.getServiceToken()}`
      }
    });
  }
  
  private async notifyShellInstances(registration: MFERegistration): Promise<void> {
    // Use EventBridge to notify all shell instances
    await this.eventBridge.putEvents({
      Entries: [{
        Source: 'banking.mfe.registry',
        DetailType: 'MFE Registered',
        Detail: JSON.stringify(registration)
      }]
    });
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="discovery-method">
                                    <h4>üì° 3. Real-time Updates via WebSocket</h4>
                                    <div class="method-details">
                                        <p>Shell app maintains a WebSocket connection to receive instant notifications about MFE changes, updates, and new deployments.</p>
                                        
                                        <div class="websocket-example">
                                            <h5>Real-time MFE Updates</h5>
                                            <pre><code class="language-typescript">// Shell App WebSocket Handler
class MFEUpdateService {
  private ws: WebSocket;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  constructor(private mfeManager: MFEManager) {
    this.connect();
  }
  
  private connect(): void {
    this.ws = new WebSocket('wss://api.bank.com/mfe-updates');
    
    this.ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      this.handleMFEUpdate(update);
    };
    
    this.ws.onclose = () => {
      this.handleReconnect();
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }
  
  private async handleMFEUpdate(update: MFEUpdateEvent): Promise<void> {
    switch (update.type) {
      case 'MFE_REGISTERED':
        await this.mfeManager.loadNewMFE(update.mfeConfig);
        this.showNotification(`New feature available: ${update.mfeConfig.name}`);
        break;
        
      case 'MFE_UPDATED':
        await this.mfeManager.updateMFE(update.mfeId, update.changes);
        if (update.requiresReload) {
          this.showUpdateNotification(update.mfeConfig.name);
        }
        break;
        
      case 'MFE_DEACTIVATED':
        await this.mfeManager.deactivateMFE(update.mfeId);
        break;
        
      case 'FEATURE_FLAG_CHANGED':
        await this.mfeManager.updateFeatureFlags(update.flags);
        break;
        
      case 'MAINTENANCE_MODE':
        this.showMaintenanceMessage(update.message);
        break;
    }
  }
  
  private handleReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, Math.pow(2, this.reconnectAttempts) * 1000);
    }
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="shell-architecture" class="content-section">
                        <h2>üèóÔ∏è Shell App Architecture</h2>
                        
                        <div class="shell-components">
                            <h3>Core Shell Components</h3>
                            <p>The shell app provides the foundational infrastructure while remaining completely agnostic to the specific MFEs it hosts.</p>
                            
                            <div class="shell-architecture-diagram">
                                <div class="shell-layer">
                                    <h4>üéØ MFE Orchestrator</h4>
                                    <div class="component-details">
                                        <p>Central controller that manages MFE lifecycle, loading, and communication</p>
                                        <pre><code class="language-typescript">class MFEOrchestrator {
  private loadedMFEs = new Map<string, MFEInstance>();
  private configService: MFEConfigService;
  private router: DynamicRouter;
  
  async initialize(): Promise<void> {
    // Load initial MFE configuration
    const config = await this.configService.fetchMFEConfig();
    
    // Initialize MFEs based on user permissions and feature flags
    for (const mfeConfig of config.mfes) {
      if (this.shouldLoadMFE(mfeConfig)) {
        await this.loadMFE(mfeConfig);
      }
    }
    
    // Setup real-time updates
    this.setupRealTimeUpdates();
    
    // Initialize routing
    this.router.initialize(this.loadedMFEs);
  }
  
  async loadMFE(config: MFEConfig): Promise<void> {
    try {
      // Validate MFE health before loading
      await this.validateMFEHealth(config);
      
      // Load MFE bundle
      const mfeInstance = await this.dynamicImport(config.entryPoint);
      
      // Initialize MFE with shared services
      await mfeInstance.initialize({
        apiClient: this.sharedServices.apiClient,
        eventBus: this.sharedServices.eventBus,
        userContext: this.sharedServices.userContext,
        theme: this.sharedServices.theme
      });
      
      // Register routes
      this.router.registerRoutes(config.id, config.routes);
      
      // Store instance
      this.loadedMFEs.set(config.id, mfeInstance);
      
      // Emit load event
      this.eventBus.emit('mfe:loaded', { id: config.id, config });
      
    } catch (error) {
      console.error(`Failed to load MFE ${config.id}:`, error);
      this.handleMFELoadError(config, error);
    }
  }
  
  private shouldLoadMFE(config: MFEConfig): boolean {
    // Check user permissions
    if (!this.userHasPermissions(config.permissions)) {
      return false;
    }
    
    // Check feature flags
    if (!this.areFeatureFlagsEnabled(config.feature_flags)) {
      return false;
    }
    
    // Check rollout percentage for beta features
    if (config.status === 'beta' && !this.isInRolloutGroup(config)) {
      return false;
    }
    
    return true;
  }
  
  async unloadMFE(mfeId: string): Promise<void> {
    const mfeInstance = this.loadedMFEs.get(mfeId);
    if (mfeInstance) {
      // Cleanup MFE resources
      await mfeInstance.cleanup?.();
      
      // Unregister routes
      this.router.unregisterRoutes(mfeId);
      
      // Remove from loaded MFEs
      this.loadedMFEs.delete(mfeId);
      
      // Emit unload event
      this.eventBus.emit('mfe:unloaded', { id: mfeId });
    }
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="shell-layer">
                                    <h4>üîó Dynamic Router</h4>
                                    <div class="component-details">
                                        <p>Handles routing between MFEs and manages route registration/deregistration at runtime</p>
                                        <pre><code class="language-typescript">class DynamicRouter {
  private routes = new Map<string, MFERoute>();
  private currentMFE: string | null = null;
  
  registerRoutes(mfeId: string, routeConfigs: RouteConfig[]): void {
    for (const routeConfig of routeConfigs) {
      const route: MFERoute = {
        mfeId,
        path: routeConfig.path,
        component: routeConfig.component,
        guards: routeConfig.guards || [],
        metadata: routeConfig.metadata
      };
      
      this.routes.set(routeConfig.path, route);
    }
    
    // Update browser history API
    this.updateRouterConfiguration();
  }
  
  async navigateToMFE(path: string): Promise<void> {
    const route = this.findMatchingRoute(path);
    
    if (!route) {
      this.handleRouteNotFound(path);
      return;
    }
    
    // Check route guards
    const canActivate = await this.checkRouteGuards(route);
    if (!canActivate) {
      this.handleUnauthorizedAccess(route);
      return;
    }
    
    // Deactivate current MFE if different
    if (this.currentMFE && this.currentMFE !== route.mfeId) {
      await this.deactivateCurrentMFE();
    }
    
    // Activate target MFE
    await this.activateMFE(route);
    
    this.currentMFE = route.mfeId;
  }
  
  private findMatchingRoute(path: string): MFERoute | null {
    // Exact match first
    if (this.routes.has(path)) {
      return this.routes.get(path)!;
    }
    
    // Pattern matching for dynamic routes
    for (const [routePath, route] of this.routes) {
      if (this.matchesPattern(path, routePath)) {
        return route;
      }
    }
    
    return null;
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="shell-layer">
                                    <h4>üîÑ Shared Services</h4>
                                    <div class="component-details">
                                        <p>Provides common services and state management across all MFEs</p>
                                        <pre><code class="language-typescript">class SharedServices {
  public readonly apiClient: APIClient;
  public readonly eventBus: EventBus;
  public readonly userContext: UserContextService;
  public readonly theme: ThemeService;
  public readonly i18n: I18nService;
  
  constructor() {
    this.apiClient = new APIClient({
      baseURL: config.apiBaseUrl,
      interceptors: [
        new AuthInterceptor(),
        new ErrorInterceptor(),
        new LoggingInterceptor()
      ]
    });
    
    this.eventBus = new EventBus();
    this.userContext = new UserContextService();
    this.theme = new ThemeService();
    this.i18n = new I18nService();
    
    this.setupCrossNavigation();
  }
  
  private setupCrossNavigation(): void {
    // Enable MFEs to navigate to each other
    this.eventBus.on('navigate', (event: NavigationEvent) => {
      this.router.navigateToMFE(event.path);
    });
    
    // Global state synchronization
    this.eventBus.on('state:update', (event: StateUpdateEvent) => {
      this.synchronizeGlobalState(event);
    });
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="runtime-config" class="content-section">
                        <h2>‚öôÔ∏è Runtime Configuration Management</h2>
                        
                        <div class="config-strategy">
                            <h3>Configuration Sources</h3>
                            <p>Multiple configuration sources ensure the shell app can adapt to changes without redeployment.</p>
                            
                            <div class="config-sources">
                                <div class="config-source">
                                    <h4>üóÉÔ∏è DynamoDB Configuration Store</h4>
                                    <div class="source-details">
                                        <p>Primary configuration source with real-time updates and global consistency</p>
                                        <pre><code class="language-typescript">class ConfigurationService {
  private dynamoClient: DynamoDBClient;
  private configCache = new Map<string, any>();
  private configSubscriptions = new Map<string, Function[]>();
  
  async fetchMFEConfiguration(): Promise<MFEConfiguration> {
    try {
      // Try cache first
      const cached = this.configCache.get('mfe_config');
      if (cached && this.isCacheValid(cached)) {
        return cached.data;
      }
      
      // Fetch from DynamoDB
      const response = await this.dynamoClient.send(new GetItemCommand({
        TableName: 'banking-mfe-config',
        Key: {
          config_type: { S: 'mfe_registry' },
          environment: { S: process.env.ENVIRONMENT || 'production' }
        }
      }));
      
      if (!response.Item) {
        throw new Error('MFE configuration not found');
      }
      
      const config = this.unmarshallConfiguration(response.Item);
      
      // Update cache
      this.configCache.set('mfe_config', {
        data: config,
        timestamp: Date.now(),
        ttl: 5 * 60 * 1000 // 5 minutes
      });
      
      return config;
    } catch (error) {
      console.error('Failed to fetch MFE configuration:', error);
      return this.getFallbackConfiguration();
    }
  }
  
  async updateMFEConfiguration(mfeId: string, updates: Partial<MFEConfig>): Promise<void> {
    await this.dynamoClient.send(new UpdateItemCommand({
      TableName: 'banking-mfe-config',
      Key: {
        config_type: { S: 'mfe_registry' },
        environment: { S: process.env.ENVIRONMENT || 'production' }
      },
      UpdateExpression: 'SET #mfes.#mfeId = :updates',
      ExpressionAttributeNames: {
        '#mfes': 'mfe_registry',
        '#mfeId': mfeId
      },
      ExpressionAttributeValues: {
        ':updates': { M: this.marshallConfiguration(updates) }
      }
    }));
    
    // Invalidate cache
    this.configCache.delete('mfe_config');
    
    // Notify subscribers
    this.notifyConfigSubscribers(mfeId, updates);
  }
  
  subscribeToConfigChanges(callback: (changes: ConfigChange) => void): void {
    // Setup DynamoDB Streams to listen for configuration changes
    this.setupDynamoDBStreamsListener(callback);
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="config-source">
                                    <h4>üö© Feature Flag Service</h4>
                                    <div class="source-details">
                                        <p>Real-time feature toggles and A/B testing configuration</p>
                                        <pre><code class="language-typescript">class FeatureFlagService {
  private flagCache = new Map<string, FeatureFlag>();
  private ws: WebSocket;
  
  async evaluateFlag(flagKey: string, userContext: UserContext): Promise<boolean> {
    const flag = await this.getFlag(flagKey);
    
    if (!flag || !flag.enabled) {
      return false;
    }
    
    // Evaluate targeting rules
    for (const rule of flag.rules) {
      if (this.evaluateRule(rule, userContext)) {
        return rule.value;
      }
    }
    
    // Default fallback
    return flag.defaultValue;
  }
  
  async getFlagsForUser(userContext: UserContext): Promise<Record<string, boolean>> {
    const allFlags = await this.getAllFlags();
    const result: Record<string, boolean> = {};
    
    for (const [key, flag] of allFlags) {
      result[key] = await this.evaluateFlag(key, userContext);
    }
    
    return result;
  }
  
  private evaluateRule(rule: TargetingRule, userContext: UserContext): boolean {
    switch (rule.type) {
      case 'user_segment':
        return userContext.segments.includes(rule.value);
        
      case 'percentage_rollout':
        const hash = this.hashUser(userContext.userId);
        return (hash % 100) < rule.percentage;
        
      case 'region':
        return userContext.region === rule.value;
        
      case 'account_type':
        return userContext.accountTypes.includes(rule.value);
        
      default:
        return false;
    }
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="module-federation" class="content-section">
                        <h2>üì¶ Module Federation Implementation</h2>
                        
                        <div class="federation-setup">
                            <h3>Webpack Module Federation Configuration</h3>
                            <p>Module Federation enables runtime loading of MFEs without rebuilding the shell application.</p>
                            
                            <div class="federation-config">
                                <h4>Shell App Configuration</h4>
                                <pre><code class="language-javascript">// webpack.config.js (Shell App)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'production',
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        // Dynamic remotes - populated at runtime
      },
      shared: {
        'react': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        '@banking/shared-components': {
          singleton: true,
          requiredVersion: '^1.5.0'
        },
        '@banking/theme': {
          singleton: true,
          requiredVersion: '^2.0.1'
        }
      }
    })
  ]
};

// Dynamic Remote Loading
class DynamicRemoteLoader {
  private remoteCache = new Map<string, any>();
  
  async loadRemote(mfeConfig: MFEConfig): Promise<any> {
    const cacheKey = `${mfeConfig.id}@${mfeConfig.version}`;
    
    if (this.remoteCache.has(cacheKey)) {
      return this.remoteCache.get(cacheKey);
    }
    
    try {
      // Dynamic import with error handling
      const container = await this.loadRemoteContainer(mfeConfig.entryPoint);
      await container.init(__webpack_share_scopes__.default);
      
      // Get the exposed module
      const factory = await container.get('./App');
      const Module = factory();
      
      // Cache the module
      this.remoteCache.set(cacheKey, Module);
      
      return Module;
    } catch (error) {
      console.error(`Failed to load remote ${mfeConfig.id}:`, error);
      throw new RemoteLoadError(mfeConfig.id, error);
    }
  }
  
  private async loadRemoteContainer(entryPoint: string): Promise<any> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = entryPoint;
      script.type = 'text/javascript';
      script.async = true;
      
      script.onload = () => {
        // Extract container name from entry point
        const containerName = this.extractContainerName(entryPoint);
        const container = window[containerName];
        
        if (container) {
          resolve(container);
        } else {
          reject(new Error(`Container ${containerName} not found`));
        }
      };
      
      script.onerror = () => {
        reject(new Error(`Failed to load script: ${entryPoint}`));
      };
      
      document.head.appendChild(script);
    });
  }
}</code></pre>
                            </div>
                            
                            <div class="mfe-config">
                                <h4>MFE Configuration</h4>
                                <pre><code class="language-javascript">// webpack.config.js (Account Dashboard MFE)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'production',
  plugins: [
    new ModuleFederationPlugin({
      name: 'accountDashboard',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App',
        './AccountSummary': './src/components/AccountSummary',
        './TransactionHistory': './src/components/TransactionHistory'
      },
      shared: {
        'react': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        '@banking/shared-components': {
          singleton: true,
          requiredVersion: '^1.5.0'
        }
      }
    })
  ]
};

// MFE Self-Registration
class MFESelfRegistration {
  async registerWithShell(): Promise<void> {
    const registration: MFERegistration = {
      id: 'account-dashboard',
      name: 'Account Dashboard',
      version: process.env.MFE_VERSION || '1.0.0',
      entryPoint: `${process.env.CDN_BASE_URL}/account-dashboard/${process.env.MFE_VERSION}/remoteEntry.js`,
      routes: ['/accounts', '/dashboard'],
      permissions: ['accounts.read', 'accounts.write'],
      healthCheck: '/health',
      metadata: {
        description: 'Customer account overview and management',
        icon: 'fas fa-chart-line',
        priority: 1,
        category: 'core'
      }
    };
    
    await fetch('/api/mfe-registry/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify(registration)
    });
  }
}</code></pre>
                            </div>
                        </div>
                    </section>

                    <section id="cors-security" class="content-section">
                        <h2>üåê CORS & Cross-Origin Security</h2>
                        
                        <div class="cors-overview">
                            <h3>CORS Challenges in MFE Architecture</h3>
                            <p>When MFEs are deployed across different domains or subdomains, Cross-Origin Resource Sharing (CORS) policies must be carefully configured to enable secure API communication while maintaining strict security boundaries.</p>
                            
                            <div class="cors-scenarios">
                                <div class="scenario-card">
                                    <h4>üè† Same-Origin Deployment</h4>
                                    <p><strong>Setup:</strong> All MFEs served from same domain (banking.company.com)</p>
                                    <p><strong>CORS Impact:</strong> No CORS restrictions</p>
                                    <p><strong>Best For:</strong> Simplified security, shared authentication</p>
                                </div>
                                
                                <div class="scenario-card">
                                    <h4>üåç Multi-Subdomain Deployment</h4>
                                    <p><strong>Setup:</strong> MFEs on subdomains (shell.bank.com, payments.bank.com)</p>
                                    <p><strong>CORS Impact:</strong> Requires subdomain CORS configuration</p>
                                    <p><strong>Best For:</strong> Team isolation, independent scaling</p>
                                </div>
                                
                                <div class="scenario-card">
                                    <h4>üîí Multi-Domain Deployment</h4>
                                    <p><strong>Setup:</strong> MFEs on different domains (bank.com, cdn.example.com)</p>
                                    <p><strong>CORS Impact:</strong> Full CORS configuration required</p>
                                    <p><strong>Best For:</strong> CDN optimization, third-party integrations</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cors-solutions">
                            <h3>Banking-Grade CORS Solutions</h3>
                            
                            <div class="solution-approach">
                                <h4>üéØ Recommended Approach: API Gateway with Proxy Pattern</h4>
                                <p>Route all API calls through a centralized gateway to eliminate CORS issues while maintaining security and audit capabilities.</p>
                                
                                <div class="architecture-diagram">
                                    <pre><code class="language-text">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Shell App     ‚îÇ    ‚îÇ   API Gateway    ‚îÇ    ‚îÇ  Backend APIs   ‚îÇ
‚îÇ (bank.com)      ‚îÇ    ‚îÇ (api.bank.com)   ‚îÇ    ‚îÇ (internal)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚Ä¢ Customer MFE  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ ‚Ä¢ CORS Headers   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ ‚Ä¢ Account API   ‚îÇ
‚îÇ ‚Ä¢ Payment MFE   ‚îÇ    ‚îÇ ‚Ä¢ Authentication ‚îÇ    ‚îÇ ‚Ä¢ Payment API   ‚îÇ
‚îÇ ‚Ä¢ Portfolio MFE ‚îÇ    ‚îÇ ‚Ä¢ Rate Limiting  ‚îÇ    ‚îÇ ‚Ä¢ Portfolio API ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ ‚Ä¢ Request Proxy  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
                                </div>
                                
                                <h4>API Gateway CORS Configuration</h4>
                                <pre><code class="language-typescript">// API Gateway CORS Configuration for Banking MFEs
class BankingAPIGateway {
  private corsConfig: CORSConfiguration;
  
  constructor() {
    this.corsConfig = {
      // Allowed origins - be specific for security
      allowedOrigins: [
        'https://banking.company.com',
        'https://shell.banking.company.com',
        'https://payments.banking.company.com',
        'https://portfolio.banking.company.com',
        'https://customer-service.banking.company.com'
      ],
      
      // Allowed methods for banking operations
      allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      
      // Required headers for banking APIs
      allowedHeaders: [
        'Content-Type',
        'Authorization',
        'X-Banking-Session-ID',
        'X-CSRF-Token',
        'X-Request-ID',
        'X-Client-Version',
        'X-MFE-Source'
      ],
      
      // Headers exposed to client
      exposedHeaders: [
        'X-Rate-Limit-Remaining',
        'X-Transaction-ID',
        'X-Request-ID'
      ],
      
      // Credentials required for authenticated requests
      allowCredentials: true,
      
      // Preflight cache duration (banking = shorter for security)
      maxAge: 300 // 5 minutes
    };
  }
  
  setupCORSMiddleware(): express.RequestHandler {
    return (req: Request, res: Response, next: NextFunction) => {
      const origin = req.headers.origin;
      
      // Validate origin against whitelist
      if (this.isAllowedOrigin(origin)) {
        res.setHeader('Access-Control-Allow-Origin', origin);
      }
      
      // Handle preflight requests
      if (req.method === 'OPTIONS') {
        res.setHeader('Access-Control-Allow-Methods', this.corsConfig.allowedMethods.join(', '));
        res.setHeader('Access-Control-Allow-Headers', this.corsConfig.allowedHeaders.join(', '));
        res.setHeader('Access-Control-Max-Age', this.corsConfig.maxAge.toString());
        res.setHeader('Access-Control-Allow-Credentials', 'true');
        
        return res.sendStatus(204);
      }
      
      // Set CORS headers for actual requests
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Expose-Headers', this.corsConfig.exposedHeaders.join(', '));
      
      // Add security headers
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      
      next();
    };
  }
  
  private isAllowedOrigin(origin: string): boolean {
    if (!origin) return false;
    
    // Exact match check
    if (this.corsConfig.allowedOrigins.includes(origin)) {
      return true;
    }
    
    // Pattern matching for dynamic subdomains (be very careful!)
    const allowedPatterns = [
      /^https:\/\/[a-z0-9-]+\.banking\.company\.com$/
    ];
    
    return allowedPatterns.some(pattern => pattern.test(origin));
  }
}</code></pre>
                                
                                <h4>MFE HTTP Client with CORS Handling</h4>
                                <pre><code class="language-typescript">// Banking MFE HTTP Client with CORS support
class BankingAPIClient {
  private baseURL: string;
  private sessionToken: string;
  
  constructor() {
    this.baseURL = process.env.REACT_APP_API_GATEWAY_URL || 'https://api.banking.company.com';
  }
  
  async request<T>(
    endpoint: string, 
    options: RequestOptions = {}
  ): Promise<APIResponse<T>> {
    
    const requestConfig: RequestInit = {
      method: options.method || 'GET',
      
      // Always include credentials for banking APIs
      credentials: 'include',
      
      headers: {
        'Content-Type': 'application/json',
        'X-Banking-Session-ID': this.getSessionId(),
        'X-CSRF-Token': await this.getCSRFToken(),
        'X-Request-ID': this.generateRequestId(),
        'X-MFE-Source': this.getMFEIdentifier(),
        'X-Client-Version': process.env.REACT_APP_VERSION,
        ...options.headers
      }
    };
    
    // Add body for POST/PUT requests
    if (options.body && ['POST', 'PUT', 'PATCH'].includes(requestConfig.method!)) {
      requestConfig.body = JSON.stringify(options.body);
    }
    
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, requestConfig);
      
      // Handle CORS errors
      if (response.type === 'opaque' || response.type === 'opaqueredirect') {
        throw new CORSError('CORS policy blocked the request');
      }
      
      // Check for rate limiting
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        throw new RateLimitError('Rate limit exceeded', retryAfter);
      }
      
      // Handle authentication errors
      if (response.status === 401) {
        await this.handleAuthenticationError();
        throw new AuthenticationError('Authentication required');
      }
      
      if (!response.ok) {
        throw new APIError(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      return {
        data,
        status: response.status,
        headers: this.extractHeaders(response.headers),
        requestId: response.headers.get('X-Request-ID')
      };
      
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('CORS')) {
        // CORS error - likely configuration issue
        throw new CORSError('CORS configuration error - check API Gateway settings');
      }
      
      throw error;
    }
  }
  
  // Handle authentication errors with redirect to ADFS
  private async handleAuthenticationError(): Promise<void> {
    // Clear local authentication state
    this.clearAuthenticationState();
    
    // Redirect to ADFS for re-authentication
    const adfsLoginURL = `${process.env.REACT_APP_ADFS_URL}/adfs/ls/` +
      `?wa=wsignin1.0&wtrealm=${encodeURIComponent(window.location.origin)}` +
      `&wctx=${encodeURIComponent(window.location.pathname)}`;
    
    window.location.href = adfsLoginURL;
  }
}</code></pre>
                            </div>
                            
                            <div class="alternative-solutions">
                                <h4>Alternative CORS Solutions</h4>
                                
                                <div class="solution-grid">
                                    <div class="solution-card">
                                        <h5>üîí Server-Side Proxy</h5>
                                        <p><strong>Approach:</strong> MFE servers proxy API calls to avoid client-side CORS</p>
                                        <p><strong>Pros:</strong> No CORS issues, secure API keys</p>
                                        <p><strong>Cons:</strong> Additional latency, server complexity</p>
                                        
                                        <pre><code class="language-javascript">// Next.js API route proxy example
// pages/api/banking/[...path].js
export default async function handler(req, res) {
  const { path } = req.query;
  const apiPath = Array.isArray(path) ? path.join('/') : path;
  
  try {
    const response = await fetch(`https://internal-api.bank.com/${apiPath}`, {
      method: req.method,
      headers: {
        'Authorization': `Bearer ${process.env.INTERNAL_API_TOKEN}`,
        'Content-Type': 'application/json',
        'X-Forwarded-For': req.headers['x-forwarded-for'] || req.connection.remoteAddress
      },
      body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
    });
    
    const data = await response.json();
    res.status(response.status).json(data);
  } catch (error) {
    res.status(500).json({ error: 'Proxy request failed' });
  }
}</code></pre>
                                    </div>
                                    
                                    <div class="solution-card">
                                        <h5>üì° WebSocket Communication</h5>
                                        <p><strong>Approach:</strong> Use WebSockets for real-time data</p>
                                        <p><strong>Pros:</strong> No CORS for WebSocket connections</p>
                                        <p><strong>Cons:</strong> Connection management complexity</p>
                                        
                                        <pre><code class="language-typescript">// WebSocket client for real-time banking data
class BankingWebSocketClient {
  private ws: WebSocket;
  private messageHandlers = new Map();
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket('wss://realtime.banking.company.com');
      
      this.ws.onopen = () => {
        this.authenticate();
        resolve();
      };
      
      this.ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        const handler = this.messageHandlers.get(message.type);
        if (handler) handler(message.data);
      };
      
      this.ws.onerror = reject;
    });
  }
  
  private authenticate(): void {
    this.ws.send(JSON.stringify({
      type: 'auth',
      token: this.getAuthToken()
    }));
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cors-security-best-practices">
                            <h3>üîê Security Best Practices</h3>
                            
                            <div class="best-practices-grid">
                                <div class="practice-card">
                                    <h4>‚úÖ Strict Origin Validation</h4>
                                    <ul>
                                        <li>Never use wildcard (*) for credentials</li>
                                        <li>Maintain explicit allowlist of origins</li>
                                        <li>Validate origins against patterns carefully</li>
                                        <li>Log all CORS violations for monitoring</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>üõ°Ô∏è Additional Security Headers</h4>
                                    <ul>
                                        <li>Content Security Policy (CSP)</li>
                                        <li>X-Frame-Options: DENY</li>
                                        <li>X-Content-Type-Options: nosniff</li>
                                        <li>Strict-Transport-Security</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>üîç Request Validation</h4>
                                    <ul>
                                        <li>Validate all incoming requests</li>
                                        <li>Implement CSRF protection</li>
                                        <li>Rate limiting per origin</li>
                                        <li>Request signing for sensitive operations</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>üìä Monitoring & Alerting</h4>
                                    <ul>
                                        <li>Monitor CORS policy violations</li>
                                        <li>Alert on suspicious cross-origin requests</li>
                                        <li>Track API usage by MFE source</li>
                                        <li>Performance impact monitoring</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="deployment-strategy" class="content-section">
                        <h2>üöÄ Zero-Downtime Deployment Strategy</h2>
                        
                        <div class="deployment-process">
                            <h3>Deployment Pipeline</h3>
                            <p>Automated deployment process that updates MFEs without affecting the shell application or other MFEs.</p>
                            
                            <div class="deployment-steps">
                                <div class="deployment-step">
                                    <div class="step-number">1</div>
                                    <div class="step-content">
                                        <h4>Build & Test</h4>
                                        <p>MFE is built, tested, and validated independently</p>
                                        <pre><code class="language-yaml"># CI/CD Pipeline for MFE
name: Deploy Account Dashboard MFE

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build MFE
        run: |
          npm ci
          npm run build
          npm run test
          
      - name: Version and Tag
        run: |
          NEW_VERSION=$(npm version patch)
          echo "MFE_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          
      - name: Upload to S3/CDN
        run: |
          aws s3 sync dist/ s3://banking-mfe-cdn/account-dashboard/$MFE_VERSION/
          aws cloudfront create-invalidation --distribution-id $CDN_DISTRIBUTION_ID
          
      - name: Update Registry
        run: |
          curl -X PATCH https://api.bank.com/mfe-registry/account-dashboard \
            -H "Authorization: Bearer $API_TOKEN" \
            -d '{
              "version": "'$MFE_VERSION'",
              "entryPoint": "https://cdn.bank.com/mfes/account-dashboard/'$MFE_VERSION'/remoteEntry.js",
              "status": "active"
            }'
            
      - name: Health Check
        run: |
          ./scripts/health-check.sh account-dashboard $MFE_VERSION</code></pre>
                                    </div>
                                </div>
                                
                                <div class="deployment-step">
                                    <div class="step-number">2</div>
                                    <div class="step-content">
                                        <h4>Canary Deployment</h4>
                                        <p>Gradual rollout to a subset of users for validation</p>
                                        <pre><code class="language-typescript">// Canary Deployment Controller
class CanaryDeploymentController {
  async deployCanary(mfeId: string, newVersion: string): Promise<void> {
    // Start with 5% of users
    await this.updateMFEConfig(mfeId, {
      version: newVersion,
      canary_percentage: 5,
      status: 'canary'
    });
    
    // Monitor metrics for 10 minutes
    await this.monitorCanaryMetrics(mfeId, newVersion, 10 * 60 * 1000);
    
    // If successful, increase to 25%
    await this.updateMFEConfig(mfeId, {
      canary_percentage: 25
    });
    
    // Continue monitoring and increasing percentage
    await this.progressiveRollout(mfeId, newVersion);
  }
  
  private async monitorCanaryMetrics(mfeId: string, version: string, duration: number): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < duration) {
      const metrics = await this.getMetrics(mfeId, version);
      
      if (this.hasUnacceptableErrors(metrics)) {
        await this.rollbackCanary(mfeId);
        throw new Error(`Canary rollback triggered for ${mfeId}`);
      }
      
      await this.sleep(30000); // Check every 30 seconds
    }
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="deployment-step">
                                    <div class="step-number">3</div>
                                    <div class="step-content">
                                        <h4>Full Rollout</h4>
                                        <p>Complete deployment to all users with automatic rollback capability</p>
                                        <pre><code class="language-typescript">// Rollout Manager
class RolloutManager {
  async completeRollout(mfeId: string, newVersion: string): Promise<void> {
    try {
      // Update configuration to use new version for all users
      await this.updateMFEConfig(mfeId, {
        version: newVersion,
        canary_percentage: 100,
        status: 'active'
      });
      
      // Notify all shell instances via WebSocket
      await this.notifyShellInstances({
        type: 'MFE_UPDATED',
        mfeId,
        newVersion,
        requiresReload: this.requiresReload(mfeId, newVersion)
      });
      
      // Monitor post-deployment metrics
      await this.monitorPostDeployment(mfeId, newVersion);
      
    } catch (error) {
      await this.automaticRollback(mfeId);
      throw error;
    }
  }
  
  private async automaticRollback(mfeId: string): Promise<void> {
    const lastKnownGood = await this.getLastKnownGoodVersion(mfeId);
    
    await this.updateMFEConfig(mfeId, {
      version: lastKnownGood.version,
      status: 'active',
      canary_percentage: 100
    });
    
    // Alert operations team
    await this.sendAlert({
      type: 'AUTOMATIC_ROLLBACK',
      mfeId,
      version: lastKnownGood.version,
      reason: 'Deployment validation failed'
    });
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <div class="next-steps">
                        <h2>Next: Implementation Details</h2>
                        <div class="next-buttons">
                            <a href="aws-architecture.html" class="btn btn-primary">AWS Infrastructure ‚Üí</a>
                            <a href="performance.html" class="btn btn-secondary">Performance & Scale ‚Üí</a>
                        </div>
                    </div>
                </article>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Banking UI Architecture - Technical Presentation</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../js/main.js"></script>
</body>
</html>