<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micro Frontend Architecture - Banking Platform</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <h2><a href="../index.html">Banking Architecture</a></h2>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="../index.html" class="nav-link">Overview</a>
                </li>
                <li class="nav-item">
                    <a href="micro-frontends.html" class="nav-link active">Micro Frontends</a>
                </li>
                <li class="nav-item">
                    <a href="aws-architecture.html" class="nav-link">AWS Infrastructure</a>
                </li>
                <li class="nav-item">
                    <a href="performance.html" class="nav-link">Performance</a>
                </li>
                <li class="nav-item">
                    <a href="resilience.html" class="nav-link">Resilience</a>
                </li>
                <li class="nav-item">
                    <a href="ai-integration.html" class="nav-link">AI Integration</a>
                </li>
            </ul>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <main class="page-content">
        <div class="container">
            <div class="page-header">
                <h1>Dynamic Micro Frontend Architecture</h1>
                <p>Scalable, runtime-configurable micro frontend system for banking applications</p>
            </div>

            <div class="content-grid">
                <aside class="sidebar">
                    <nav class="page-nav">
                        <h3>Contents</h3>
                        <ul>
                            <li><a href="#overview">Architecture Overview</a></li>
                            <li><a href="#dynamic-discovery">Dynamic MFE Discovery</a></li>
                            <li><a href="#shell-architecture">Shell App Architecture</a></li>
                            <li><a href="#runtime-config">Runtime Configuration</a></li>
                            <li><a href="#module-federation">Module Federation</a></li>
                            <li><a href="#cors-security">CORS & Security</a></li>
                            <li><a href="#deployment-strategy">Deployment Strategy</a></li>
                            <li><a href="#versioning">Version Management</a></li>
                            <li><a href="#performance">Performance Optimization</a></li>
                        </ul>
                    </nav>
                </aside>

                <article class="main-content">
                    <section id="mfe-overview" class="content-section">
                        <h2>🧩 Dynamic Micro Frontend Architecture</h2>
                        
                        <div class="mfe-intro">
                            <p>The banking platform implements a sophisticated micro frontend architecture that eliminates the need to rebuild the shell application when individual MFEs are updated. This approach enables true team autonomy while maintaining system coherence.</p>
                            
                            <div class="architecture-benefits">
                                <h3>Key Benefits</h3>
                                <ul>
                                    <li><strong>Independent Deployments:</strong> Teams can deploy MFEs without coordinating with other teams</li>
                                    <li><strong>Technology Diversity:</strong> Different MFEs can use different frameworks (React, Vue, Angular)</li>
                                    <li><strong>Failure Isolation:</strong> One MFE failure doesn't bring down the entire application</li>
                                    <li><strong>Team Autonomy:</strong> Reduced dependencies and faster development cycles</li>
                                    <li><strong>A/B Testing:</strong> Deploy different versions to different user segments</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="mfe-flow-diagram">
                            <h3>🔄 Dynamic Discovery Flow</h3>
                            <p>The complete flow of how MFEs are dynamically discovered, loaded, and integrated at runtime:</p>
                            
                            <div class="flow-diagram">
                                <pre><code class="language-text">     [User Opens Banking App]
                │
                ▼
    ┌──────────────────────┐
    │    Shell App         │◄─── Initial Load & Authentication
    │    Bootstraps        │
    └─────────┬────────────┘
              │
              ▼
    ┌──────────────────────┐     ┌─────────────────────────┐
    │   MFE Registry       │────►│      DynamoDB           │
    │   Query              │     │  • Available MFEs       │
    └─────────┬────────────┘     │  • User Permissions     │
              │                  │  • Health Status        │
              ▼                  └─────────────────────────┘
    ┌──────────────────────┐
    │   Health Checks      │
    │   (Parallel)         │
    └─────────┬────────────┘
              │
              ▼
    ┌──────────────────────┐     ┌─────────────────────────┐
    │   Dynamic Import     │────►│   Module Federation     │
    │   & Version Check    │     │   Runtime Loading       │
    └─────────┬────────────┘     └─────────────────────────┘
              │
              ▼
    ┌──────────────────────┐     ┌─────────────────────────┐ 
    │   MFE Mount &        │◄────┤   Event Bus Setup       │
    │   Integration        │     │   State Management      │
    └─────────┬────────────┘     └─────────────────────────┘
              │
              ▼
    ┌──────────────────────┐     ┌─────────────────────────┐
    │  User Interaction    │◄────┤  Real-time Updates      │
    │  & Navigation        │     │  WebSocket/SSE          │
    └──────────────────────┘     └─────────────────────────┘</code></pre>
                            </div>
                            
                            <div class="flow-phases">
                                <h4>Flow Phases Breakdown</h4>
                                <div class="phase-grid">
                                    <div class="phase-card">
                                        <h5>Phase 1: Authentication</h5>
                                        <ul>
                                            <li>Shell app loads and validates JWT token</li>
                                            <li>ADFS SAML authentication if needed</li>
                                            <li>Extract user permissions and role</li>
                                        </ul>
                                    </div>
                                    <div class="phase-card">
                                        <h5>Phase 2: Discovery</h5>
                                        <ul>
                                            <li>Query DynamoDB MFE registry</li>
                                            <li>Filter MFEs by user permissions</li>
                                            <li>Get MFE URLs and configurations</li>
                                        </ul>
                                    </div>
                                    <div class="phase-card">
                                        <h5>Phase 3: Health & Load</h5>
                                        <ul>
                                            <li>Parallel health checks for all MFEs</li>
                                            <li>Dynamic import via Module Federation</li>
                                            <li>Version compatibility validation</li>
                                        </ul>
                                    </div>
                                    <div class="phase-card">
                                        <h5>Phase 4: Integration</h5>
                                        <ul>
                                            <li>Mount MFEs in designated containers</li>
                                            <li>Setup event bus communication</li>
                                            <li>Initialize shared state management</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>                    <section id="dynamic-discovery" class="content-section">
                        <h2>🔍 Dynamic MFE Discovery System</h2>
                        
                        <div class="discovery-strategy">
                            <h3>Discovery Mechanisms</h3>
                            <p>The shell app uses multiple strategies to discover and load MFEs dynamically without requiring code changes or redeployment.</p>
                            
                            <div class="discovery-methods">
                                <div class="discovery-method">
                                    <h4>📋 1. Configuration-Based Discovery</h4>
                                    <div class="method-details">
                                        <p>MFE configurations are stored in DynamoDB and fetched at runtime, allowing instant updates without shell redeployment.</p>
                                        
                                        <div class="config-example">
                                            <h5>MFE Registry Configuration</h5>
                                            <pre><code class="language-json">{
  "mfe_registry": {
    "account-dashboard": {
      "id": "account-dashboard",
      "name": "Account Dashboard",
      "version": "2.1.3",
      "status": "active",
      "entry_point": "https://cdn.bank.com/mfes/account-dashboard/2.1.3/bundle.js",
      "css": "https://cdn.bank.com/mfes/account-dashboard/2.1.3/styles.css",
      "routes": ["/accounts", "/dashboard"],
      "permissions": ["accounts.read", "accounts.write"],
      "team": "accounts-team",
      "deployment_regions": ["us-east-1", "eu-west-1"],
      "feature_flags": {
        "dark_mode": true,
        "advanced_charts": false,
        "real_time_updates": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "banking_theme": "^2.0.1"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Customer account overview and management",
        "icon": "fas fa-chart-line",
        "priority": 1,
        "category": "core"
      }
    },
    "payment-transfer": {
      "id": "payment-transfer",
      "name": "Payment & Transfer",
      "version": "1.8.2",
      "status": "active",
      "entry_point": "https://cdn.bank.com/mfes/payment-transfer/1.8.2/bundle.js",
      "css": "https://cdn.bank.com/mfes/payment-transfer/1.8.2/styles.css",
      "routes": ["/payments", "/transfers"],
      "permissions": ["payments.create", "transfers.create"],
      "team": "payments-team",
      "deployment_regions": ["us-east-1", "eu-west-1"],
      "feature_flags": {
        "international_transfers": true,
        "crypto_support": false,
        "instant_payments": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "payment_validation": "^3.2.1"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Payment processing and money transfers",
        "icon": "fas fa-credit-card",
        "priority": 2,
        "category": "core"
      }
    },
    "investment-portfolio": {
      "id": "investment-portfolio",
      "name": "Investment Portfolio",
      "version": "1.2.0-beta",
      "status": "beta",
      "entry_point": "https://cdn.bank.com/mfes/investment-portfolio/1.2.0-beta/bundle.js",
      "css": "https://cdn.bank.com/mfes/investment-portfolio/1.2.0-beta/styles.css",
      "routes": ["/investments", "/portfolio"],
      "permissions": ["investments.read", "portfolio.manage"],
      "team": "wealth-management-team",
      "deployment_regions": ["us-east-1"],
      "rollout_percentage": 10,
      "target_user_segments": ["premium", "wealth_management"],
      "feature_flags": {
        "options_trading": false,
        "crypto_investments": false,
        "ai_recommendations": true
      },
      "dependencies": {
        "shared_components": "^1.5.0",
        "market_data": "^2.1.0"
      },
      "health_check": "/health",
      "metadata": {
        "description": "Investment portfolio management and tracking",
        "icon": "fas fa-chart-pie",
        "priority": 3,
        "category": "premium"
      }
    }
  },
  "global_config": {
    "theme": "corporate-2024",
    "api_base_url": "https://api.bank.com/v2",
    "feature_toggles": {
      "maintenance_mode": false,
      "new_user_onboarding": true,
      "beta_features_enabled": true
    },
    "performance_budgets": {
      "max_bundle_size": "250kb",
      "max_load_time": "2000ms"
    }
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="discovery-method">
                                    <h4>🔄 2. Runtime Registration API</h4>
                                    <div class="method-details">
                                        <p>New MFEs can register themselves with the shell app through a registration API, enabling immediate availability.</p>
                                        
                                        <div class="api-example">
                                            <h5>MFE Registration Endpoint</h5>
                                            <pre><code class="language-typescript">// MFE Registration API
interface MFERegistration {
  id: string;
  name: string;
  version: string;
  entryPoint: string;
  routes: string[];
  permissions: string[];
  healthCheck?: string;
  metadata?: MFEMetadata;
}

class MFERegistryService {
  private registryEndpoint = 'https://api.bank.com/mfe-registry';
  
  async registerMFE(registration: MFERegistration): Promise<void> {
    const response = await fetch(`${this.registryEndpoint}/register`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify({
        ...registration,
        timestamp: new Date().toISOString(),
        deploymentId: process.env.DEPLOYMENT_ID,
        region: process.env.AWS_REGION
      })
    });
    
    if (!response.ok) {
      throw new Error(`Failed to register MFE: ${response.statusText}`);
    }
    
    // Notify all shell instances of the new MFE
    await this.notifyShellInstances(registration);
  }
  
  async updateMFE(id: string, updates: Partial<MFERegistration>): Promise<void> {
    await fetch(`${this.registryEndpoint}/mfes/${id}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify(updates)
    });
  }
  
  async deregisterMFE(id: string): Promise<void> {
    await fetch(`${this.registryEndpoint}/mfes/${id}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${this.getServiceToken()}`
      }
    });
  }
  
  private async notifyShellInstances(registration: MFERegistration): Promise<void> {
    // Use EventBridge to notify all shell instances
    await this.eventBridge.putEvents({
      Entries: [{
        Source: 'banking.mfe.registry',
        DetailType: 'MFE Registered',
        Detail: JSON.stringify(registration)
      }]
    });
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="discovery-method">
                                    <h4>📡 3. Real-time Updates via WebSocket</h4>
                                    <div class="method-details">
                                        <p>Shell app maintains a WebSocket connection to receive instant notifications about MFE changes, updates, and new deployments.</p>
                                        
                                        <div class="websocket-example">
                                            <h5>Real-time MFE Updates</h5>
                                            <pre><code class="language-typescript">// Shell App WebSocket Handler
class MFEUpdateService {
  private ws: WebSocket;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  constructor(private mfeManager: MFEManager) {
    this.connect();
  }
  
  private connect(): void {
    this.ws = new WebSocket('wss://api.bank.com/mfe-updates');
    
    this.ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      this.handleMFEUpdate(update);
    };
    
    this.ws.onclose = () => {
      this.handleReconnect();
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }
  
  private async handleMFEUpdate(update: MFEUpdateEvent): Promise<void> {
    switch (update.type) {
      case 'MFE_REGISTERED':
        await this.mfeManager.loadNewMFE(update.mfeConfig);
        this.showNotification(`New feature available: ${update.mfeConfig.name}`);
        break;
        
      case 'MFE_UPDATED':
        await this.mfeManager.updateMFE(update.mfeId, update.changes);
        if (update.requiresReload) {
          this.showUpdateNotification(update.mfeConfig.name);
        }
        break;
        
      case 'MFE_DEACTIVATED':
        await this.mfeManager.deactivateMFE(update.mfeId);
        break;
        
      case 'FEATURE_FLAG_CHANGED':
        await this.mfeManager.updateFeatureFlags(update.flags);
        break;
        
      case 'MAINTENANCE_MODE':
        this.showMaintenanceMessage(update.message);
        break;
    }
  }
  
  private handleReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, Math.pow(2, this.reconnectAttempts) * 1000);
    }
  }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="shell-architecture" class="content-section">
                        <h2>🏗️ Shell App Architecture</h2>
                        
                        <div class="shell-components">
                            <h3>Core Shell Components</h3>
                            <p>The shell app provides the foundational infrastructure while remaining completely agnostic to the specific MFEs it hosts.</p>
                            
                            <div class="shell-architecture-diagram">
                                <div class="shell-layer">
                                    <h4>🎯 MFE Orchestrator</h4>
                                    <div class="component-details">
                                        <p>Central controller that manages MFE lifecycle, loading, and communication</p>
                                        <pre><code class="language-typescript">class MFEOrchestrator {
  private loadedMFEs = new Map<string, MFEInstance>();
  private configService: MFEConfigService;
  private router: DynamicRouter;
  
  async initialize(): Promise<void> {
    // Load initial MFE configuration
    const config = await this.configService.fetchMFEConfig();
    
    // Initialize MFEs based on user permissions and feature flags
    for (const mfeConfig of config.mfes) {
      if (this.shouldLoadMFE(mfeConfig)) {
        await this.loadMFE(mfeConfig);
      }
    }
    
    // Setup real-time updates
    this.setupRealTimeUpdates();
    
    // Initialize routing
    this.router.initialize(this.loadedMFEs);
  }
  
  async loadMFE(config: MFEConfig): Promise<void> {
    try {
      // Validate MFE health before loading
      await this.validateMFEHealth(config);
      
      // Load MFE bundle
      const mfeInstance = await this.dynamicImport(config.entryPoint);
      
      // Initialize MFE with shared services
      await mfeInstance.initialize({
        apiClient: this.sharedServices.apiClient,
        eventBus: this.sharedServices.eventBus,
        userContext: this.sharedServices.userContext,
        theme: this.sharedServices.theme
      });
      
      // Register routes
      this.router.registerRoutes(config.id, config.routes);
      
      // Store instance
      this.loadedMFEs.set(config.id, mfeInstance);
      
      // Emit load event
      this.eventBus.emit('mfe:loaded', { id: config.id, config });
      
    } catch (error) {
      console.error(`Failed to load MFE ${config.id}:`, error);
      this.handleMFELoadError(config, error);
    }
  }
  
  private shouldLoadMFE(config: MFEConfig): boolean {
    // Check user permissions
    if (!this.userHasPermissions(config.permissions)) {
      return false;
    }
    
    // Check feature flags
    if (!this.areFeatureFlagsEnabled(config.feature_flags)) {
      return false;
    }
    
    // Check rollout percentage for beta features
    if (config.status === 'beta' && !this.isInRolloutGroup(config)) {
      return false;
    }
    
    return true;
  }
  
  async unloadMFE(mfeId: string): Promise<void> {
    const mfeInstance = this.loadedMFEs.get(mfeId);
    if (mfeInstance) {
      // Cleanup MFE resources
      await mfeInstance.cleanup?.();
      
      // Unregister routes
      this.router.unregisterRoutes(mfeId);
      
      // Remove from loaded MFEs
      this.loadedMFEs.delete(mfeId);
      
      // Emit unload event
      this.eventBus.emit('mfe:unloaded', { id: mfeId });
    }
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="shell-layer">
                                    <h4>🔗 Dynamic Router</h4>
                                    <div class="component-details">
                                        <p>Handles routing between MFEs and manages route registration/deregistration at runtime</p>
                                        <pre><code class="language-typescript">class DynamicRouter {
  private routes = new Map<string, MFERoute>();
  private currentMFE: string | null = null;
  
  registerRoutes(mfeId: string, routeConfigs: RouteConfig[]): void {
    for (const routeConfig of routeConfigs) {
      const route: MFERoute = {
        mfeId,
        path: routeConfig.path,
        component: routeConfig.component,
        guards: routeConfig.guards || [],
        metadata: routeConfig.metadata
      };
      
      this.routes.set(routeConfig.path, route);
    }
    
    // Update browser history API
    this.updateRouterConfiguration();
  }
  
  async navigateToMFE(path: string): Promise<void> {
    const route = this.findMatchingRoute(path);
    
    if (!route) {
      this.handleRouteNotFound(path);
      return;
    }
    
    // Check route guards
    const canActivate = await this.checkRouteGuards(route);
    if (!canActivate) {
      this.handleUnauthorizedAccess(route);
      return;
    }
    
    // Deactivate current MFE if different
    if (this.currentMFE && this.currentMFE !== route.mfeId) {
      await this.deactivateCurrentMFE();
    }
    
    // Activate target MFE
    await this.activateMFE(route);
    
    this.currentMFE = route.mfeId;
  }
  
  private findMatchingRoute(path: string): MFERoute | null {
    // Exact match first
    if (this.routes.has(path)) {
      return this.routes.get(path)!;
    }
    
    // Pattern matching for dynamic routes
    for (const [routePath, route] of this.routes) {
      if (this.matchesPattern(path, routePath)) {
        return route;
      }
    }
    
    return null;
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="shell-layer">
                                    <h4>🔄 Shared Services</h4>
                                    <div class="component-details">
                                        <p>Provides common services and state management across all MFEs</p>
                                        <pre><code class="language-typescript">class SharedServices {
  public readonly apiClient: APIClient;
  public readonly eventBus: EventBus;
  public readonly userContext: UserContextService;
  public readonly theme: ThemeService;
  public readonly i18n: I18nService;
  
  constructor() {
    this.apiClient = new APIClient({
      baseURL: config.apiBaseUrl,
      interceptors: [
        new AuthInterceptor(),
        new ErrorInterceptor(),
        new LoggingInterceptor()
      ]
    });
    
    this.eventBus = new EventBus();
    this.userContext = new UserContextService();
    this.theme = new ThemeService();
    this.i18n = new I18nService();
    
    this.setupCrossNavigation();
  }
  
  private setupCrossNavigation(): void {
    // Enable MFEs to navigate to each other
    this.eventBus.on('navigate', (event: NavigationEvent) => {
      this.router.navigateToMFE(event.path);
    });
    
    // Global state synchronization
    this.eventBus.on('state:update', (event: StateUpdateEvent) => {
      this.synchronizeGlobalState(event);
    });
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="runtime-config" class="content-section">
                        <h2>⚙️ Runtime Configuration Management</h2>
                        
                        <div class="config-strategy">
                            <h3>Configuration Sources</h3>
                            <p>Multiple configuration sources ensure the shell app can adapt to changes without redeployment.</p>
                            
                            <div class="config-sources">
                                <div class="config-source">
                                    <h4>🗃️ DynamoDB Configuration Store</h4>
                                    <div class="source-details">
                                        <p>Primary configuration source with real-time updates and global consistency</p>
                                        <pre><code class="language-typescript">class ConfigurationService {
  private dynamoClient: DynamoDBClient;
  private configCache = new Map<string, any>();
  private configSubscriptions = new Map<string, Function[]>();
  
  async fetchMFEConfiguration(): Promise<MFEConfiguration> {
    try {
      // Try cache first
      const cached = this.configCache.get('mfe_config');
      if (cached && this.isCacheValid(cached)) {
        return cached.data;
      }
      
      // Fetch from DynamoDB
      const response = await this.dynamoClient.send(new GetItemCommand({
        TableName: 'banking-mfe-config',
        Key: {
          config_type: { S: 'mfe_registry' },
          environment: { S: process.env.ENVIRONMENT || 'production' }
        }
      }));
      
      if (!response.Item) {
        throw new Error('MFE configuration not found');
      }
      
      const config = this.unmarshallConfiguration(response.Item);
      
      // Update cache
      this.configCache.set('mfe_config', {
        data: config,
        timestamp: Date.now(),
        ttl: 5 * 60 * 1000 // 5 minutes
      });
      
      return config;
    } catch (error) {
      console.error('Failed to fetch MFE configuration:', error);
      return this.getFallbackConfiguration();
    }
  }
  
  async updateMFEConfiguration(mfeId: string, updates: Partial<MFEConfig>): Promise<void> {
    await this.dynamoClient.send(new UpdateItemCommand({
      TableName: 'banking-mfe-config',
      Key: {
        config_type: { S: 'mfe_registry' },
        environment: { S: process.env.ENVIRONMENT || 'production' }
      },
      UpdateExpression: 'SET #mfes.#mfeId = :updates',
      ExpressionAttributeNames: {
        '#mfes': 'mfe_registry',
        '#mfeId': mfeId
      },
      ExpressionAttributeValues: {
        ':updates': { M: this.marshallConfiguration(updates) }
      }
    }));
    
    // Invalidate cache
    this.configCache.delete('mfe_config');
    
    // Notify subscribers
    this.notifyConfigSubscribers(mfeId, updates);
  }
  
  subscribeToConfigChanges(callback: (changes: ConfigChange) => void): void {
    // Setup DynamoDB Streams to listen for configuration changes
    this.setupDynamoDBStreamsListener(callback);
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="config-source">
                                    <h4>🚩 Feature Flag Service</h4>
                                    <div class="source-details">
                                        <p>Real-time feature toggles and A/B testing configuration</p>
                                        <pre><code class="language-typescript">class FeatureFlagService {
  private flagCache = new Map<string, FeatureFlag>();
  private ws: WebSocket;
  
  async evaluateFlag(flagKey: string, userContext: UserContext): Promise<boolean> {
    const flag = await this.getFlag(flagKey);
    
    if (!flag || !flag.enabled) {
      return false;
    }
    
    // Evaluate targeting rules
    for (const rule of flag.rules) {
      if (this.evaluateRule(rule, userContext)) {
        return rule.value;
      }
    }
    
    // Default fallback
    return flag.defaultValue;
  }
  
  async getFlagsForUser(userContext: UserContext): Promise<Record<string, boolean>> {
    const allFlags = await this.getAllFlags();
    const result: Record<string, boolean> = {};
    
    for (const [key, flag] of allFlags) {
      result[key] = await this.evaluateFlag(key, userContext);
    }
    
    return result;
  }
  
  private evaluateRule(rule: TargetingRule, userContext: UserContext): boolean {
    switch (rule.type) {
      case 'user_segment':
        return userContext.segments.includes(rule.value);
        
      case 'percentage_rollout':
        const hash = this.hashUser(userContext.userId);
        return (hash % 100) < rule.percentage;
        
      case 'region':
        return userContext.region === rule.value;
        
      case 'account_type':
        return userContext.accountTypes.includes(rule.value);
        
      default:
        return false;
    }
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mermaid-flow-section">
                                <h4>🔄 Detailed Mermaid Flow Diagram</h4>
                                <p>Interactive flowchart showing the complete MFE discovery, loading, and state management process:</p>
                                
                                <div class="mermaid-container">
                                    <div class="mermaid">
flowchart TD
    A[User Opens Banking App] --> B[Shell App Initialization]
    B --> C[Check localStorage for JWT]
    C --> D{Valid JWT Token?}
    D -->|No| E[Redirect to ADFS Login]
    D -->|Yes| F[Validate Token with Auth API]
    
    E --> G[SAML Authentication]
    G --> H[Receive JWT + Permissions]
    H --> F
    F --> I[Extract User Context]
    
    I --> J[Query DynamoDB MFE Registry]
    J --> K[Filter MFEs by User Role]
    K --> L[Get Environment-specific URLs]
    
    L --> M[Parallel Health Checks]
    M --> N{All MFEs Healthy?}
    N -->|No| O[Check Cache for Failed MFEs]
    N -->|Yes| P[Load MFE Configurations]
    
    O --> Q{Cached Version Available?}
    Q -->|Yes| R[Load from Cache with Warning]
    Q -->|No| S[Load Fallback UI]
    
    P --> T[Dynamic Import via Module Federation]
    T --> U[Version Compatibility Check]
    U --> V{Compatible?}
    V -->|No| W[Load Compatible Fallback Version]
    V -->|Yes| X[Initialize MFE Container]
    
    R --> X
    S --> X
    W --> X
    
    X --> Y[Setup Redux Store Connection]
    Y --> Z[Initialize Event Bus]
    Z --> AA[Mount MFE in DOM]
    AA --> BB[Subscribe to State Updates]
    BB --> CC[Setup WebSocket Connection]
    CC --> DD[MFE Ready for Interaction]
    
    DD --> EE[User Navigation Event]
    EE --> FF{Target MFE Loaded?}
    FF -->|Yes| GG[Route to Existing MFE]
    FF -->|No| HH[Trigger Lazy Load]
    HH --> J
    GG --> DD
    
    %% State Management Flow
    DD --> II[User Action in MFE]
    II --> JJ[Dispatch Redux Action]
    JJ --> KK[Action Type Check]
    KK --> LL{Cross-MFE Action?}
    LL -->|Yes| MM[Publish to Event Bus]
    LL -->|No| NN[Update Local State]
    MM --> OO[Other MFEs Subscribe]
    OO --> PP[Update Shared State]
    PP --> QQ[Re-render Components]
    NN --> QQ
    
    %% Real-time Updates
    CC --> RR[WebSocket Message Received]
    RR --> SS[Parse Banking Event]
    SS --> TT{Account Balance Update?}
    TT -->|Yes| UU[Update Account MFE State]
    TT -->|No| VV{Transaction Alert?}
    VV -->|Yes| WW[Show Notification]
    VV -->|No| XX[Route to Handler]
    UU --> QQ
    WW --> QQ
    XX --> QQ

    classDef userAction fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef systemProcess fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef errorState fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef successState fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    
    class A,EE,II userAction
    class B,F,I,J,P,T,Y,Z,AA,CC systemProcess
    class D,N,Q,V,FF,LL,TT,VV decision
    class E,O,S,W errorState
    class DD,QQ successState
                                    </div>
                                </div>
                            </div>
                            
                            <div class="dynamodb-structure">
                                <h4>🗄️ DynamoDB MFE Registry Structure</h4>
                                <p>Complete data model for managing MFE configurations, versions, and deployments:</p>
                                
                                <div class="db-schema">
                                    <h5>📋 Table Schema Design</h5>
                                    <pre><code class="language-json">// DynamoDB Table: banking-mfe-registry
{
  "TableName": "banking-mfe-registry",
  "KeySchema": [
    {
      "AttributeName": "mfe_id",
      "KeyType": "HASH"    // Partition Key
    },
    {
      "AttributeName": "version_environment", 
      "KeyType": "RANGE"   // Sort Key: "2.1.0#production"
    }
  ],
  "GlobalSecondaryIndexes": [
    {
      "IndexName": "environment-status-index",
      "KeySchema": [
        {
          "AttributeName": "environment",
          "KeyType": "HASH"
        },
        {
          "AttributeName": "status",
          "KeyType": "RANGE"
        }
      ]
    },
    {
      "IndexName": "active-version-index", 
      "KeySchema": [
        {
          "AttributeName": "mfe_id",
          "KeyType": "HASH"
        },
        {
          "AttributeName": "is_active",
          "KeyType": "RANGE"
        }
      ]
    }
  ]
}</code></pre>
                                </div>
                                
                                <div class="sample-records">
                                    <h5>📝 Sample MFE Registry Records</h5>
                                    <pre><code class="language-json">// Active Production Account MFE
{
  "mfe_id": "account_mfe",
  "version_environment": "2.1.0#production",
  "version": "2.1.0",
  "environment": "production",
  "is_active": "true",
  "status": "active",
  "deployment_config": {
    "remote_entry_url": "https://account.banking.com/remoteEntry.js",
    "health_check_url": "https://account.banking.com/health",
    "cdn_urls": {
      "primary": "https://cdn.banking.com/account-mfe/2.1.0/",
      "fallback": "https://backup-cdn.banking.com/account-mfe/2.1.0/"
    }
  },
  "permissions": {
    "required_roles": ["customer", "premium_customer", "business_customer"],
    "required_permissions": ["account:read", "account:write", "transaction:read"],
    "restricted_roles": ["guest", "suspended"]
  },
  "compatibility": {
    "shell_version_min": "1.5.0",
    "shell_version_max": "2.0.0",
    "react_version": "^18.0.0",
    "shared_dependencies": {
      "@banking/design-system": "^3.2.0",
      "@banking/utils": "^1.8.0"
    }
  },
  "feature_flags": {
    "enable_investment_view": true,
    "enable_credit_score": false,
    "beta_features": ["quick_transfer", "budget_insights"]
  },
  "performance_config": {
    "lazy_load": false,
    "preload_priority": "high",
    "bundle_size_limit": "500kb",
    "load_timeout": 10000
  },
  "rollback_config": {
    "previous_version": "2.0.8",
    "rollback_trigger": "error_rate_threshold",
    "error_threshold": 0.05
  },
  "metadata": {
    "team": "account-team",
    "deployed_by": "ci-cd-pipeline",
    "deployed_at": "2024-10-20T10:30:00Z",
    "git_commit": "abc123def456",
    "build_number": "1247"
  },
  "ttl": 1735689600  // TTL for cleanup of old versions
}

// Staging Version for Testing
{
  "mfe_id": "account_mfe",
  "version_environment": "2.2.0-beta.1#staging",
  "version": "2.2.0-beta.1",
  "environment": "staging",
  "is_active": "true",
  "status": "active",
  "deployment_config": {
    "remote_entry_url": "https://staging-account.banking.com/remoteEntry.js",
    "health_check_url": "https://staging-account.banking.com/health"
  },
  "feature_flags": {
    "enable_investment_view": true,
    "enable_credit_score": true,  // Testing new feature
    "beta_features": ["quick_transfer", "budget_insights", "ai_recommendations"]
  },
  // ... other fields similar to production
}

// Payment MFE with A/B Testing
{
  "mfe_id": "payment_mfe",
  "version_environment": "1.8.0#production",
  "version": "1.8.0",
  "environment": "production", 
  "is_active": "true",
  "status": "active",
  "deployment_config": {
    "remote_entry_url": "https://payment.banking.com/remoteEntry.js",
    "health_check_url": "https://payment.banking.com/health"
  },
  "ab_testing": {
    "enabled": true,
    "variants": [
      {
        "variant_id": "new_ui",
        "traffic_percentage": 10,
        "remote_entry_url": "https://payment.banking.com/v2/remoteEntry.js"
      },
      {
        "variant_id": "original",
        "traffic_percentage": 90, 
        "remote_entry_url": "https://payment.banking.com/remoteEntry.js"
      }
    ]
  },
  "permissions": {
    "required_roles": ["customer", "premium_customer", "business_customer"],
    "required_permissions": ["payment:read", "payment:write", "transfer:execute"],
    "restricted_roles": ["guest", "limited_access"]
  }
}

// Canary Deployment Record
{
  "mfe_id": "investment_mfe",
  "version_environment": "3.0.0#production-canary",
  "version": "3.0.0",
  "environment": "production",
  "is_active": "true", 
  "status": "canary",
  "canary_config": {
    "traffic_percentage": 5,
    "target_users": ["premium_customer", "wealth_management"],
    "success_metrics": {
      "error_rate_threshold": 0.01,
      "response_time_p95": 500,
      "user_satisfaction": 4.5
    },
    "rollback_conditions": {
      "error_rate_breach": true,
      "performance_degradation": true,
      "user_feedback_negative": true
    }
  }
}</code></pre>
                                </div>
                            </div>
                            
                            <div class="version-management">
                                <h4>🔄 Version Management Strategy</h4>
                                
                                <div class="management-sections">
                                    <div class="management-card">
                                        <h5>Active Version Resolution</h5>
                                        <pre><code class="language-typescript">// Version Resolution Service
class MFEVersionManager {
  async getActiveMFE(mfeId: string, userContext: UserContext): Promise<MFEConfig> {
    const environment = process.env.NODE_ENV || 'production';
    
    // 1. Check for user-specific overrides (A/B testing, canary)
    const userOverride = await this.checkUserOverrides(mfeId, userContext);
    if (userOverride) {
      return userOverride;
    }
    
    // 2. Get active version for environment
    const activeVersion = await this.dynamoClient.query({
      TableName: 'banking-mfe-registry',
      IndexName: 'active-version-index',
      KeyConditionExpression: 'mfe_id = :mfe_id AND is_active = :active',
      FilterExpression: 'environment = :env AND #status = :status',
      ExpressionAttributeNames: {
        '#status': 'status'
      },
      ExpressionAttributeValues: {
        ':mfe_id': mfeId,
        ':active': 'true',
        ':env': environment,
        ':status': 'active'
      }
    }).promise();
    
    if (!activeVersion.Items?.length) {
      throw new Error(`No active version found for ${mfeId} in ${environment}`);
    }
    
    // 3. Return highest version if multiple active (shouldn't happen in production)
    return this.selectBestVersion(activeVersion.Items, userContext);
  }
  
  private async checkUserOverrides(
    mfeId: string, 
    userContext: UserContext
  ): Promise<MFEConfig | null> {
    
    // Check for A/B testing participation
    const abConfig = await this.getABTestConfig(mfeId, userContext);
    if (abConfig) {
      return abConfig;
    }
    
    // Check for canary deployment eligibility
    const canaryConfig = await this.getCanaryConfig(mfeId, userContext);
    if (canaryConfig) {
      return canaryConfig;
    }
    
    // Check for user-specific beta features
    const betaConfig = await this.getBetaConfig(mfeId, userContext);
    if (betaConfig) {
      return betaConfig;
    }
    
    return null;
  }
}</code></pre>
                                    </div>
                                    
                                    <div class="management-card">
                                        <h5>Deployment Pipeline Integration</h5>
                                        <pre><code class="language-typescript">// Deployment Management
class MFEDeploymentManager {
  
  // Blue-Green Deployment
  async deployBlueGreen(mfeId: string, newVersion: string): Promise<void> {
    // 1. Deploy to staging environment first
    await this.deployToEnvironment(mfeId, newVersion, 'staging');
    
    // 2. Run automated tests
    const testResults = await this.runAutomatedTests(mfeId, newVersion, 'staging');
    if (!testResults.passed) {
      throw new Error(`Tests failed for ${mfeId}@${newVersion}`);
    }
    
    // 3. Deploy to production as inactive
    await this.deployToEnvironment(mfeId, newVersion, 'production', false);
    
    // 4. Run production smoke tests
    const smokeTests = await this.runSmokeTests(mfeId, newVersion, 'production');
    if (!smokeTests.passed) {
      await this.rollback(mfeId, 'production');
      throw new Error(`Smoke tests failed for ${mfeId}@${newVersion}`);
    }
    
    // 5. Switch traffic (atomic operation)
    await this.switchTraffic(mfeId, newVersion, 'production');
    
    // 6. Monitor for 15 minutes
    await this.monitorDeployment(mfeId, newVersion, 900000); // 15 minutes
  }
  
  // Canary Deployment
  async deployCanary(
    mfeId: string, 
    newVersion: string, 
    canaryPercentage: number = 5
  ): Promise<void> {
    
    const canaryRecord = {
      mfe_id: mfeId,
      version_environment: `${newVersion}#production-canary`,
      version: newVersion,
      environment: 'production',
      is_active: 'true',
      status: 'canary',
      canary_config: {
        traffic_percentage: canaryPercentage,
        start_time: new Date().toISOString(),
        success_metrics: {
          error_rate_threshold: 0.01,
          response_time_p95: 500,
          conversion_rate_drop_threshold: 0.05
        }
      }
    };
    
    // Deploy canary version
    await this.dynamoClient.putItem({
      TableName: 'banking-mfe-registry',
      Item: canaryRecord
    }).promise();
    
    // Monitor canary metrics
    this.startCanaryMonitoring(mfeId, newVersion);
  }
  
  private async switchTraffic(
    mfeId: string, 
    newVersion: string, 
    environment: string
  ): Promise<void> {
    
    // Atomic switch using DynamoDB transactions
    const transactionItems = [
      // Deactivate old version
      {
        Update: {
          TableName: 'banking-mfe-registry',
          Key: { 
            mfe_id: mfeId,
            version_environment: await this.getCurrentActiveVersion(mfeId, environment)
          },
          UpdateExpression: 'SET is_active = :inactive, deactivated_at = :now',
          ExpressionAttributeValues: {
            ':inactive': 'false',
            ':now': new Date().toISOString()
          }
        }
      },
      // Activate new version  
      {
        Update: {
          TableName: 'banking-mfe-registry',
          Key: {
            mfe_id: mfeId,
            version_environment: `${newVersion}#${environment}`
          },
          UpdateExpression: 'SET is_active = :active, activated_at = :now',
          ExpressionAttributeValues: {
            ':active': 'true',
            ':now': new Date().toISOString()
          }
        }
      }
    ];
    
    await this.dynamoClient.transactWrite({
      TransactItems: transactionItems
    }).promise();
    
    // Invalidate CDN cache
    await this.invalidateCDNCache(mfeId);
    
    // Notify monitoring systems
    await this.notifyDeployment(mfeId, newVersion, environment);
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="state-management-integration">
                                <h4>🔄 State Management & Real-time Synchronization</h4>
                                <p>Detailed implementation of cross-MFE state management with real-time updates:</p>
                                
                                <div class="state-flow-diagram">
                                    <h5>Redux Store Integration Flow</h5>
                                    <div class="mermaid-container">
                                        <div class="mermaid">
graph TD
    A[User Action in Account MFE] --> B[Dispatch Redux Action]
    B --> C{Action Type Analysis}
    C -->|LOCAL_ONLY| D[Update Account MFE State]
    C -->|CROSS_MFE| E[Publish to Event Bus]
    C -->|GLOBAL_STATE| F[Update Shared Redux Store]
    
    E --> G[Payment MFE Subscribes]
    E --> H[Navigation MFE Subscribes]
    E --> I[Shell App Subscribes]
    
    G --> J[Update Payment State]
    H --> K[Update Navigation Badge]
    I --> L[Update Global Context]
    
    F --> M[All MFEs Get State Update]
    M --> N[Re-render Components]
    
    D --> N
    J --> N
    K --> N
    L --> N
    
    %% WebSocket Integration
    O[WebSocket Server Message] --> P[Parse Banking Event]
    P --> Q{Event Type}
    Q -->|BALANCE_UPDATE| R[Update Account Store]
    Q -->|TRANSACTION_ALERT| S[Show Notification]
    Q -->|FRAUD_ALERT| T[Security Action Required]
    
    R --> F
    S --> U[Notification MFE]
    T --> V[Security MFE Load]
    
    classDef userAction fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef systemProcess fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    classDef decision fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef realtime fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    
    class A userAction
    class B,E,F,M,P systemProcess
    class C,Q decision
    class O,R,S,T realtime
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="advanced-patterns">
                                    <h5>Advanced State Synchronization Patterns</h5>
                                    <pre><code class="language-typescript">// Advanced State Management for Banking MFEs
interface BankingStateManager {
  // Cross-MFE State Synchronization
  syncState<T>(
    sourceState: T, 
    targetMFEs: string[], 
    syncStrategy: 'immediate' | 'batched' | 'optimistic'
  ): Promise<void>;
  
  // Conflict Resolution for Concurrent Updates
  resolveConflict<T>(
    currentState: T, 
    incomingState: T, 
    conflictStrategy: ConflictResolutionStrategy
  ): T;
  
  // Real-time Event Processing
  processRealtimeEvent(
    event: BankingEvent, 
    affectedMFEs?: string[]
  ): Promise<void>;
}

class BankingStateManager implements BankingStateManager {
  private eventBus: EventBus;
  private store: EnhancedStore;
  private websocket: WebSocketManager;
  private conflictResolver: ConflictResolver;
  
  constructor() {
    this.setupEventBus();
    this.initializeWebSocketHandlers();
    this.configureConflictResolution();
  }
  
  // Optimistic Updates with Rollback
  async optimisticUpdate<T>(
    mfeId: string,
    stateKey: string,
    optimisticValue: T,
    serverOperation: () => Promise<T>
  ): Promise<T> {
    
    // 1. Apply optimistic update immediately
    const previousState = this.store.getState()[stateKey];
    this.store.dispatch({
      type: 'OPTIMISTIC_UPDATE',
      payload: { stateKey, value: optimisticValue, mfeId }
    });
    
    // 2. Update UI immediately
    this.notifyMFEs([mfeId], stateKey, optimisticValue);
    
    try {
      // 3. Execute server operation
      const serverResult = await serverOperation();
      
      // 4. Confirm optimistic update
      this.store.dispatch({
        type: 'CONFIRM_OPTIMISTIC_UPDATE',
        payload: { stateKey, value: serverResult, mfeId }
      });
      
      return serverResult;
      
    } catch (error) {
      // 5. Rollback on failure
      this.store.dispatch({
        type: 'ROLLBACK_OPTIMISTIC_UPDATE', 
        payload: { stateKey, previousValue: previousState, mfeId }
      });
      
      // 6. Notify user of failure
      this.eventBus.publish('OPERATION_FAILED', {
        mfeId,
        operation: 'optimistic_update',
        error: error.message
      });
      
      throw error;
    }
  }
  
  // Cross-MFE State Synchronization
  async syncState<T>(
    sourceState: T,
    targetMFEs: string[],
    syncStrategy: 'immediate' | 'batched' | 'optimistic' = 'immediate'
  ): Promise<void> {
    
    switch (syncStrategy) {
      case 'immediate':
        await Promise.all(
          targetMFEs.map(mfeId => 
            this.sendStateUpdate(mfeId, sourceState)
          )
        );
        break;
        
      case 'batched':
        this.batchStateUpdates(targetMFEs, sourceState);
        break;
        
      case 'optimistic':
        // Apply immediately, sync in background
        this.notifyMFEs(targetMFEs, 'state_update', sourceState);
        this.backgroundSync(targetMFEs, sourceState);
        break;
    }
  }
  
  // Real-time WebSocket Event Processing
  async processRealtimeEvent(
    event: BankingEvent,
    affectedMFEs?: string[]
  ): Promise<void> {
    
    const timestamp = Date.now();
    
    // Validate event integrity
    if (!this.validateEvent(event)) {
      console.error('Invalid banking event received:', event);
      return;
    }
    
    // Determine affected MFEs if not specified
    if (!affectedMFEs) {
      affectedMFEs = this.determineAffectedMFEs(event);
    }
    
    // Process based on event type
    switch (event.type) {
      case 'ACCOUNT_BALANCE_UPDATE':
        await this.handleBalanceUpdate(event, affectedMFEs);
        break;
        
      case 'TRANSACTION_COMPLETED':
        await this.handleTransactionComplete(event, affectedMFEs);
        break;
        
      case 'FRAUD_ALERT':
        await this.handleSecurityAlert(event, affectedMFEs);
        break;
        
      case 'SESSION_TIMEOUT_WARNING':
        await this.handleSessionWarning(event);
        break;
    }
    
    // Log for audit trail
    this.auditLogger.logStateChange({
      eventType: event.type,
      affectedMFEs,
      timestamp,
      userId: event.userId,
      metadata: event.metadata
    });
  }
  
  // Advanced Conflict Resolution
  resolveConflict<T>(
    currentState: T,
    incomingState: T,
    strategy: ConflictResolutionStrategy
  ): T {
    
    switch (strategy) {
      case 'last_write_wins':
        return incomingState;
        
      case 'merge_deep':
        return this.deepMerge(currentState, incomingState);
        
      case 'user_preference':
        return this.resolveByUserPreference(currentState, incomingState);
        
      case 'banking_priority':
        return this.resolveBankingConflict(currentState, incomingState);
        
      default:
        throw new Error(`Unknown conflict resolution strategy: ${strategy}`);
    }
  }
  
  private resolveBankingConflict<T>(current: T, incoming: T): T {
    // Banking-specific conflict resolution rules
    
    // 1. Account balance: Always use server value
    if (this.isBalanceUpdate(current, incoming)) {
      return incoming;
    }
    
    // 2. Transaction status: Prioritize completed over pending
    if (this.isTransactionUpdate(current, incoming)) {
      return this.prioritizeTransactionStatus(current, incoming);
    }
    
    // 3. Security settings: Always use most restrictive
    if (this.isSecurityUpdate(current, incoming)) {
      return this.chooseMostRestrictive(current, incoming);
    }
    
    // 4. User preferences: Merge with server override for critical settings
    return this.mergeWithBankingRules(current, incoming);
  }
}</code></pre>
                                </div>
                                
                                <div class="performance-optimization">
                                    <h5>Performance Optimization Strategies</h5>
                                    <pre><code class="language-typescript">// Performance-Optimized State Management
class PerformantBankingStateManager {
  private stateCache: Map<string, CachedState> = new Map();
  private updateQueue: StateUpdate[] = [];
  private batchTimer: NodeJS.Timeout | null = null;
  
  // Intelligent State Caching
  async getCachedState<T>(
    stateKey: string, 
    mfeId: string,
    maxAge: number = 5000 // 5 seconds default
  ): Promise<T | null> {
    
    const cacheKey = `${mfeId}:${stateKey}`;
    const cached = this.stateCache.get(cacheKey);
    
    if (!cached) return null;
    
    // Check if cache is still valid
    if (Date.now() - cached.timestamp > maxAge) {
      this.stateCache.delete(cacheKey);
      return null;
    }
    
    // Banking-specific cache validation
    if (this.isCriticalBankingData(stateKey)) {
      // Always validate critical data with server
      const isValid = await this.validateWithServer(stateKey, cached.data);
      if (!isValid) {
        this.stateCache.delete(cacheKey);
        return null;
      }
    }
    
    return cached.data as T;
  }
  
  // Batched State Updates for Performance
  batchStateUpdate(mfeId: string, stateKey: string, value: any): void {
    this.updateQueue.push({
      mfeId,
      stateKey,
      value,
      timestamp: Date.now()
    });
    
    // Debounce batch processing
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
    }
    
    this.batchTimer = setTimeout(() => {
      this.processBatchedUpdates();
    }, 16); // ~60fps for smooth UI updates
  }
  
  private async processBatchedUpdates(): Promise<void> {
    if (this.updateQueue.length === 0) return;
    
    // Group updates by MFE
    const updatesByMFE = this.groupUpdatesByMFE(this.updateQueue);
    
    // Process updates in parallel
    await Promise.all(
      Object.entries(updatesByMFE).map(([mfeId, updates]) =>
        this.applyBatchedUpdates(mfeId, updates)
      )
    );
    
    // Clear queue
    this.updateQueue = [];
    this.batchTimer = null;
  }
  
  // Memory Management for Large State Objects
  manageStateMemory(): void {
    const memoryThreshold = 50 * 1024 * 1024; // 50MB
    const currentMemory = this.calculateStateMemoryUsage();
    
    if (currentMemory > memoryThreshold) {
      this.optimizeMemoryUsage();
    }
  }
  
  private optimizeMemoryUsage(): void {
    // 1. Remove expired cache entries
    this.cleanExpiredCache();
    
    // 2. Compress large state objects
    this.compressLargeStates();
    
    // 3. Offload non-critical data to IndexedDB
    this.offloadToIndexedDB();
    
    // 4. Garbage collect unused MFE states
    this.garbageCollectUnusedStates();
  }
}</code></pre>
                                </div>
                            </div>
                            
                            <div class="error-handling-flow">
                                <h4>🛡️ Error Handling & Fallback Decision Tree</h4>
                                <p>Comprehensive error handling ensures banking operations continue even when individual MFEs fail:</p>
                                
                                <div class="decision-tree">
                                    <pre><code class="language-text">    [MFE Load Request]
            │
            ▼
    ┌─────────────────┐
    │  Health Check   │
    └─────────┬───────┘
              │
         ┌────▼────┐
         │ Healthy? │
         └────┬────┘
              │
        ┌─────▼─────┐─────┐
        │    Yes    │ No  │
        └─────┬─────┘     │
              │           │
              ▼           ▼
    ┌─────────────────┐   ┌─────────────────┐
    │  Load Fresh MFE │   │  Check Cache    │
    └─────────┬───────┘   └─────────┬───────┘
              │                     │
         ┌────▼────┐            ┌────▼────┐
         │Success? │            │ Cached? │
         └────┬────┘            └────┬────┘
              │                      │
        ┌─────▼─────┐─────┐    ┌─────▼─────┐─────┐
        │    Yes    │ No  │    │    Yes    │ No  │
        └─────┬─────┘     │    └─────┬─────┘     │
              │           │          │           │
              ▼           ▼          ▼           ▼
    ┌─────────────────┐   │ ┌─────────────────┐   │
    │   Mount MFE     │   │ │ Load Cached MFE │   │
    └─────────────────┘   │ └─────────────────┘   │
                          │                       │
                          ▼                       ▼
                ┌─────────────────┐     ┌─────────────────┐
                │ Retry Logic     │     │ Fallback UI     │
                │ (3 attempts)    │     │ (Limited Func)  │
                └─────────────────┘     └─────────────────┘</code></pre>
                                </div>
                                
                                <div class="fallback-strategies">
                                    <h5>Fallback Strategies by MFE Type</h5>
                                    <div class="strategy-grid">
                                        <div class="strategy-item">
                                            <strong>Account MFE:</strong> Show cached balance with "Data may be outdated" warning
                                        </div>
                                        <div class="strategy-item">
                                            <strong>Payment MFE:</strong> Queue transactions for later processing, show status
                                        </div>
                                        <div class="strategy-item">
                                            <strong>Investment MFE:</strong> Display static portfolio view, disable trading
                                        </div>
                                        <div class="strategy-item">
                                            <strong>Settings MFE:</strong> Use minimal form with essential fields only
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="module-federation" class="content-section">
                        <h2>📦 Module Federation Implementation</h2>
                        
                        <div class="federation-setup">
                            <h3>Webpack Module Federation Configuration</h3>
                            <p>Module Federation enables runtime loading of MFEs without rebuilding the shell application.</p>
                            
                            <div class="federation-config">
                                <h4>Shell App Configuration</h4>
                                <pre><code class="language-javascript">// webpack.config.js (Shell App)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'production',
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        // Dynamic remotes - populated at runtime
      },
      shared: {
        'react': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        '@banking/shared-components': {
          singleton: true,
          requiredVersion: '^1.5.0'
        },
        '@banking/theme': {
          singleton: true,
          requiredVersion: '^2.0.1'
        }
      }
    })
  ]
};

// Dynamic Remote Loading
class DynamicRemoteLoader {
  private remoteCache = new Map<string, any>();
  
  async loadRemote(mfeConfig: MFEConfig): Promise<any> {
    const cacheKey = `${mfeConfig.id}@${mfeConfig.version}`;
    
    if (this.remoteCache.has(cacheKey)) {
      return this.remoteCache.get(cacheKey);
    }
    
    try {
      // Dynamic import with error handling
      const container = await this.loadRemoteContainer(mfeConfig.entryPoint);
      await container.init(__webpack_share_scopes__.default);
      
      // Get the exposed module
      const factory = await container.get('./App');
      const Module = factory();
      
      // Cache the module
      this.remoteCache.set(cacheKey, Module);
      
      return Module;
    } catch (error) {
      console.error(`Failed to load remote ${mfeConfig.id}:`, error);
      throw new RemoteLoadError(mfeConfig.id, error);
    }
  }
  
  private async loadRemoteContainer(entryPoint: string): Promise<any> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = entryPoint;
      script.type = 'text/javascript';
      script.async = true;
      
      script.onload = () => {
        // Extract container name from entry point
        const containerName = this.extractContainerName(entryPoint);
        const container = window[containerName];
        
        if (container) {
          resolve(container);
        } else {
          reject(new Error(`Container ${containerName} not found`));
        }
      };
      
      script.onerror = () => {
        reject(new Error(`Failed to load script: ${entryPoint}`));
      };
      
      document.head.appendChild(script);
    });
  }
}</code></pre>
                            </div>
                            
                            <div class="mfe-config">
                                <h4>MFE Configuration</h4>
                                <pre><code class="language-javascript">// webpack.config.js (Account Dashboard MFE)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'production',
  plugins: [
    new ModuleFederationPlugin({
      name: 'accountDashboard',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App',
        './AccountSummary': './src/components/AccountSummary',
        './TransactionHistory': './src/components/TransactionHistory'
      },
      shared: {
        'react': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.0.0'
        },
        '@banking/shared-components': {
          singleton: true,
          requiredVersion: '^1.5.0'
        }
      }
    })
  ]
};

// MFE Self-Registration
class MFESelfRegistration {
  async registerWithShell(): Promise<void> {
    const registration: MFERegistration = {
      id: 'account-dashboard',
      name: 'Account Dashboard',
      version: process.env.MFE_VERSION || '1.0.0',
      entryPoint: `${process.env.CDN_BASE_URL}/account-dashboard/${process.env.MFE_VERSION}/remoteEntry.js`,
      routes: ['/accounts', '/dashboard'],
      permissions: ['accounts.read', 'accounts.write'],
      healthCheck: '/health',
      metadata: {
        description: 'Customer account overview and management',
        icon: 'fas fa-chart-line',
        priority: 1,
        category: 'core'
      }
    };
    
    await fetch('/api/mfe-registry/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getServiceToken()}`
      },
      body: JSON.stringify(registration)
    });
  }
}</code></pre>
                            </div>
                        </div>
                    </section>

                    <section id="cors-security" class="content-section">
                        <h2>🌐 CORS & Cross-Origin Security</h2>
                        
                        <div class="cors-overview">
                            <h3>CORS Challenges in MFE Architecture</h3>
                            <p>When MFEs are deployed across different domains or subdomains, Cross-Origin Resource Sharing (CORS) policies must be carefully configured to enable secure API communication while maintaining strict security boundaries.</p>
                            
                            <div class="cors-scenarios">
                                <div class="scenario-card">
                                    <h4>🏠 Same-Origin Deployment</h4>
                                    <p><strong>Setup:</strong> All MFEs served from same domain (banking.company.com)</p>
                                    <p><strong>CORS Impact:</strong> No CORS restrictions</p>
                                    <p><strong>Best For:</strong> Simplified security, shared authentication</p>
                                </div>
                                
                                <div class="scenario-card">
                                    <h4>🌍 Multi-Subdomain Deployment</h4>
                                    <p><strong>Setup:</strong> MFEs on subdomains (shell.bank.com, payments.bank.com)</p>
                                    <p><strong>CORS Impact:</strong> Requires subdomain CORS configuration</p>
                                    <p><strong>Best For:</strong> Team isolation, independent scaling</p>
                                </div>
                                
                                <div class="scenario-card">
                                    <h4>🔒 Multi-Domain Deployment</h4>
                                    <p><strong>Setup:</strong> MFEs on different domains (bank.com, cdn.example.com)</p>
                                    <p><strong>CORS Impact:</strong> Full CORS configuration required</p>
                                    <p><strong>Best For:</strong> CDN optimization, third-party integrations</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cors-solutions">
                            <h3>Banking-Grade CORS Solutions</h3>
                            
                            <div class="solution-approach">
                                <h4>🎯 Recommended Approach: API Gateway with Proxy Pattern</h4>
                                <p>Route all API calls through a centralized gateway to eliminate CORS issues while maintaining security and audit capabilities.</p>
                                
                                <div class="architecture-diagram">
                                    <pre><code class="language-text">┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Shell App     │    │   API Gateway    │    │  Backend APIs   │
│ (bank.com)      │    │ (api.bank.com)   │    │ (internal)      │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ • Customer MFE  │───▶│ • CORS Headers   │───▶│ • Account API   │
│ • Payment MFE   │    │ • Authentication │    │ • Payment API   │
│ • Portfolio MFE │    │ • Rate Limiting  │    │ • Portfolio API │
└─────────────────┘    │ • Request Proxy  │    └─────────────────┘
                       └──────────────────┘</code></pre>
                                </div>
                                
                                <h4>API Gateway CORS Configuration</h4>
                                <pre><code class="language-typescript">// API Gateway CORS Configuration for Banking MFEs
class BankingAPIGateway {
  private corsConfig: CORSConfiguration;
  
  constructor() {
    this.corsConfig = {
      // Allowed origins - be specific for security
      allowedOrigins: [
        'https://banking.company.com',
        'https://shell.banking.company.com',
        'https://payments.banking.company.com',
        'https://portfolio.banking.company.com',
        'https://customer-service.banking.company.com'
      ],
      
      // Allowed methods for banking operations
      allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      
      // Required headers for banking APIs
      allowedHeaders: [
        'Content-Type',
        'Authorization',
        'X-Banking-Session-ID',
        'X-CSRF-Token',
        'X-Request-ID',
        'X-Client-Version',
        'X-MFE-Source'
      ],
      
      // Headers exposed to client
      exposedHeaders: [
        'X-Rate-Limit-Remaining',
        'X-Transaction-ID',
        'X-Request-ID'
      ],
      
      // Credentials required for authenticated requests
      allowCredentials: true,
      
      // Preflight cache duration (banking = shorter for security)
      maxAge: 300 // 5 minutes
    };
  }
  
  setupCORSMiddleware(): express.RequestHandler {
    return (req: Request, res: Response, next: NextFunction) => {
      const origin = req.headers.origin;
      
      // Validate origin against whitelist
      if (this.isAllowedOrigin(origin)) {
        res.setHeader('Access-Control-Allow-Origin', origin);
      }
      
      // Handle preflight requests
      if (req.method === 'OPTIONS') {
        res.setHeader('Access-Control-Allow-Methods', this.corsConfig.allowedMethods.join(', '));
        res.setHeader('Access-Control-Allow-Headers', this.corsConfig.allowedHeaders.join(', '));
        res.setHeader('Access-Control-Max-Age', this.corsConfig.maxAge.toString());
        res.setHeader('Access-Control-Allow-Credentials', 'true');
        
        return res.sendStatus(204);
      }
      
      // Set CORS headers for actual requests
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Expose-Headers', this.corsConfig.exposedHeaders.join(', '));
      
      // Add security headers
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      
      next();
    };
  }
  
  private isAllowedOrigin(origin: string): boolean {
    if (!origin) return false;
    
    // Exact match check
    if (this.corsConfig.allowedOrigins.includes(origin)) {
      return true;
    }
    
    // Pattern matching for dynamic subdomains (be very careful!)
    const allowedPatterns = [
      /^https:\/\/[a-z0-9-]+\.banking\.company\.com$/
    ];
    
    return allowedPatterns.some(pattern => pattern.test(origin));
  }
}</code></pre>
                                
                                <h4>MFE HTTP Client with CORS Handling</h4>
                                <pre><code class="language-typescript">// Banking MFE HTTP Client with CORS support
class BankingAPIClient {
  private baseURL: string;
  private sessionToken: string;
  
  constructor() {
    this.baseURL = process.env.REACT_APP_API_GATEWAY_URL || 'https://api.banking.company.com';
  }
  
  async request<T>(
    endpoint: string, 
    options: RequestOptions = {}
  ): Promise<APIResponse<T>> {
    
    const requestConfig: RequestInit = {
      method: options.method || 'GET',
      
      // Always include credentials for banking APIs
      credentials: 'include',
      
      headers: {
        'Content-Type': 'application/json',
        'X-Banking-Session-ID': this.getSessionId(),
        'X-CSRF-Token': await this.getCSRFToken(),
        'X-Request-ID': this.generateRequestId(),
        'X-MFE-Source': this.getMFEIdentifier(),
        'X-Client-Version': process.env.REACT_APP_VERSION,
        ...options.headers
      }
    };
    
    // Add body for POST/PUT requests
    if (options.body && ['POST', 'PUT', 'PATCH'].includes(requestConfig.method!)) {
      requestConfig.body = JSON.stringify(options.body);
    }
    
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, requestConfig);
      
      // Handle CORS errors
      if (response.type === 'opaque' || response.type === 'opaqueredirect') {
        throw new CORSError('CORS policy blocked the request');
      }
      
      // Check for rate limiting
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        throw new RateLimitError('Rate limit exceeded', retryAfter);
      }
      
      // Handle authentication errors
      if (response.status === 401) {
        await this.handleAuthenticationError();
        throw new AuthenticationError('Authentication required');
      }
      
      if (!response.ok) {
        throw new APIError(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      return {
        data,
        status: response.status,
        headers: this.extractHeaders(response.headers),
        requestId: response.headers.get('X-Request-ID')
      };
      
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('CORS')) {
        // CORS error - likely configuration issue
        throw new CORSError('CORS configuration error - check API Gateway settings');
      }
      
      throw error;
    }
  }
  
  // Handle authentication errors with redirect to ADFS
  private async handleAuthenticationError(): Promise<void> {
    // Clear local authentication state
    this.clearAuthenticationState();
    
    // Redirect to ADFS for re-authentication
    const adfsLoginURL = `${process.env.REACT_APP_ADFS_URL}/adfs/ls/` +
      `?wa=wsignin1.0&wtrealm=${encodeURIComponent(window.location.origin)}` +
      `&wctx=${encodeURIComponent(window.location.pathname)}`;
    
    window.location.href = adfsLoginURL;
  }
}</code></pre>
                            </div>
                            
                            <div class="alternative-solutions">
                                <h4>Alternative CORS Solutions</h4>
                                
                                <div class="solution-grid">
                                    <div class="solution-card">
                                        <h5>🔒 Server-Side Proxy</h5>
                                        <p><strong>Approach:</strong> MFE servers proxy API calls to avoid client-side CORS</p>
                                        <p><strong>Pros:</strong> No CORS issues, secure API keys</p>
                                        <p><strong>Cons:</strong> Additional latency, server complexity</p>
                                        
                                        <pre><code class="language-javascript">// Next.js API route proxy example
// pages/api/banking/[...path].js
export default async function handler(req, res) {
  const { path } = req.query;
  const apiPath = Array.isArray(path) ? path.join('/') : path;
  
  try {
    const response = await fetch(`https://internal-api.bank.com/${apiPath}`, {
      method: req.method,
      headers: {
        'Authorization': `Bearer ${process.env.INTERNAL_API_TOKEN}`,
        'Content-Type': 'application/json',
        'X-Forwarded-For': req.headers['x-forwarded-for'] || req.connection.remoteAddress
      },
      body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
    });
    
    const data = await response.json();
    res.status(response.status).json(data);
  } catch (error) {
    res.status(500).json({ error: 'Proxy request failed' });
  }
}</code></pre>
                                    </div>
                                    
                                    <div class="solution-card">
                                        <h5>📡 WebSocket Communication</h5>
                                        <p><strong>Approach:</strong> Use WebSockets for real-time data</p>
                                        <p><strong>Pros:</strong> No CORS for WebSocket connections</p>
                                        <p><strong>Cons:</strong> Connection management complexity</p>
                                        
                                        <pre><code class="language-typescript">// WebSocket client for real-time banking data
class BankingWebSocketClient {
  private ws: WebSocket;
  private messageHandlers = new Map();
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket('wss://realtime.banking.company.com');
      
      this.ws.onopen = () => {
        this.authenticate();
        resolve();
      };
      
      this.ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        const handler = this.messageHandlers.get(message.type);
        if (handler) handler(message.data);
      };
      
      this.ws.onerror = reject;
    });
  }
  
  private authenticate(): void {
    this.ws.send(JSON.stringify({
      type: 'auth',
      token: this.getAuthToken()
    }));
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cors-security-best-practices">
                            <h3>🔐 Security Best Practices</h3>
                            
                            <div class="best-practices-grid">
                                <div class="practice-card">
                                    <h4>✅ Strict Origin Validation</h4>
                                    <ul>
                                        <li>Never use wildcard (*) for credentials</li>
                                        <li>Maintain explicit allowlist of origins</li>
                                        <li>Validate origins against patterns carefully</li>
                                        <li>Log all CORS violations for monitoring</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>🛡️ Additional Security Headers</h4>
                                    <ul>
                                        <li>Content Security Policy (CSP)</li>
                                        <li>X-Frame-Options: DENY</li>
                                        <li>X-Content-Type-Options: nosniff</li>
                                        <li>Strict-Transport-Security</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>🔍 Request Validation</h4>
                                    <ul>
                                        <li>Validate all incoming requests</li>
                                        <li>Implement CSRF protection</li>
                                        <li>Rate limiting per origin</li>
                                        <li>Request signing for sensitive operations</li>
                                    </ul>
                                </div>
                                
                                <div class="practice-card">
                                    <h4>📊 Monitoring & Alerting</h4>
                                    <ul>
                                        <li>Monitor CORS policy violations</li>
                                        <li>Alert on suspicious cross-origin requests</li>
                                        <li>Track API usage by MFE source</li>
                                        <li>Performance impact monitoring</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="deployment-strategy" class="content-section">
                        <h2>🚀 Zero-Downtime Deployment Strategy</h2>
                        
                        <div class="deployment-process">
                            <h3>Deployment Pipeline</h3>
                            <p>Automated deployment process that updates MFEs without affecting the shell application or other MFEs.</p>
                            
                            <div class="deployment-steps">
                                <div class="deployment-step">
                                    <div class="step-number">1</div>
                                    <div class="step-content">
                                        <h4>Build & Test</h4>
                                        <p>MFE is built, tested, and validated independently</p>
                                        <pre><code class="language-yaml"># CI/CD Pipeline for MFE
name: Deploy Account Dashboard MFE

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build MFE
        run: |
          npm ci
          npm run build
          npm run test
          
      - name: Version and Tag
        run: |
          NEW_VERSION=$(npm version patch)
          echo "MFE_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          
      - name: Upload to S3/CDN
        run: |
          aws s3 sync dist/ s3://banking-mfe-cdn/account-dashboard/$MFE_VERSION/
          aws cloudfront create-invalidation --distribution-id $CDN_DISTRIBUTION_ID
          
      - name: Update Registry
        run: |
          curl -X PATCH https://api.bank.com/mfe-registry/account-dashboard \
            -H "Authorization: Bearer $API_TOKEN" \
            -d '{
              "version": "'$MFE_VERSION'",
              "entryPoint": "https://cdn.bank.com/mfes/account-dashboard/'$MFE_VERSION'/remoteEntry.js",
              "status": "active"
            }'
            
      - name: Health Check
        run: |
          ./scripts/health-check.sh account-dashboard $MFE_VERSION</code></pre>
                                    </div>
                                </div>
                                
                                <div class="deployment-step">
                                    <div class="step-number">2</div>
                                    <div class="step-content">
                                        <h4>Canary Deployment</h4>
                                        <p>Gradual rollout to a subset of users for validation</p>
                                        <pre><code class="language-typescript">// Canary Deployment Controller
class CanaryDeploymentController {
  async deployCanary(mfeId: string, newVersion: string): Promise<void> {
    // Start with 5% of users
    await this.updateMFEConfig(mfeId, {
      version: newVersion,
      canary_percentage: 5,
      status: 'canary'
    });
    
    // Monitor metrics for 10 minutes
    await this.monitorCanaryMetrics(mfeId, newVersion, 10 * 60 * 1000);
    
    // If successful, increase to 25%
    await this.updateMFEConfig(mfeId, {
      canary_percentage: 25
    });
    
    // Continue monitoring and increasing percentage
    await this.progressiveRollout(mfeId, newVersion);
  }
  
  private async monitorCanaryMetrics(mfeId: string, version: string, duration: number): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < duration) {
      const metrics = await this.getMetrics(mfeId, version);
      
      if (this.hasUnacceptableErrors(metrics)) {
        await this.rollbackCanary(mfeId);
        throw new Error(`Canary rollback triggered for ${mfeId}`);
      }
      
      await this.sleep(30000); // Check every 30 seconds
    }
  }
}</code></pre>
                                    </div>
                                </div>
                                
                                <div class="deployment-step">
                                    <div class="step-number">3</div>
                                    <div class="step-content">
                                        <h4>Full Rollout</h4>
                                        <p>Complete deployment to all users with automatic rollback capability</p>
                                        <pre><code class="language-typescript">// Rollout Manager
class RolloutManager {
  async completeRollout(mfeId: string, newVersion: string): Promise<void> {
    try {
      // Update configuration to use new version for all users
      await this.updateMFEConfig(mfeId, {
        version: newVersion,
        canary_percentage: 100,
        status: 'active'
      });
      
      // Notify all shell instances via WebSocket
      await this.notifyShellInstances({
        type: 'MFE_UPDATED',
        mfeId,
        newVersion,
        requiresReload: this.requiresReload(mfeId, newVersion)
      });
      
      // Monitor post-deployment metrics
      await this.monitorPostDeployment(mfeId, newVersion);
      
    } catch (error) {
      await this.automaticRollback(mfeId);
      throw error;
    }
  }
  
  private async automaticRollback(mfeId: string): Promise<void> {
    const lastKnownGood = await this.getLastKnownGoodVersion(mfeId);
    
    await this.updateMFEConfig(mfeId, {
      version: lastKnownGood.version,
      status: 'active',
      canary_percentage: 100
    });
    
    // Alert operations team
    await this.sendAlert({
      type: 'AUTOMATIC_ROLLBACK',
      mfeId,
      version: lastKnownGood.version,
      reason: 'Deployment validation failed'
    });
  }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <div class="next-steps">
                        <h2>Next: Implementation Details</h2>
                        <div class="next-buttons">
                            <a href="aws-architecture.html" class="btn btn-primary">AWS Infrastructure →</a>
                            <a href="performance.html" class="btn btn-secondary">Performance & Scale →</a>
                        </div>
                    </div>
                </article>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Banking UI Architecture - Technical Presentation</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../js/main.js"></script>
    
    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#1B365D',
                primaryTextColor: '#333',
                primaryBorderColor: '#4A90E2',
                lineColor: '#666',
                secondaryColor: '#F8F9FA',
                tertiaryColor: '#E3F2FD'
            },
            flowchart: {
                curve: 'basis',
                padding: 20
            }
        });
    </script>
</body>
</html>